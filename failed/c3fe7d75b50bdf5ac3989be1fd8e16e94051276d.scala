abstract class I0() {
val i1: I4;
val I4: i1.I4 = new i1 {}
val I4: Int = 1
var I4: Int = 0;
def I4(I4: Int) = i1 + I4
val I4 = i1
}
object I4 {
implicit def I4(erased I4: Int)(I4: Int)(I4: Int, I4: Int): Int = I4 + I4
def I4(I4: Int, I4: Int) = I4 + I4
val I4 = i1
I4 = I4
val I4 = I0
val I4 = I4 match {
case _: i1 => Some
def i1[I4](I4: String): I4 = new I4[I4]
I4
} new {
val I4 = new I0
def I4[I4](I4: I4): I4 = I4 match {
case I0(i1) => i1 ++ I2
}
}
trait i1 {
def i1(i1: i1) = I2 match {
case i1: I4[I4] => i1.I4.I4 =>
val I2: I4[I4] = I2
var I2: I4[I3] =
new I4
println
}
import I0.i1 {
object I4 { def I4(I4: i1): I4 = new I4().I4().I4(); new I4().I4(); I4 }
}