class i0 {
final val i0 =
def I6(I6: String): Any = i0
}
trait I6 {
import i0.{ i0 =>
}
private var I6 = size type I6 = I6 with I6 }
trait I6 extends i0 {
type i0 = Int
val I6: i0 = I6
()
}
var I6: I6 = new I6
implicit def I6[I6, I6]: I6 & I2 @I6 =>
type I6[I6 <: I6, I6 <: I6[I6]
def head : I6[Int, Nil]
}
trait I5 extends i0 with i0 {
val I2: I6[i0, I6, _] = I2
val I2 = new I6[Any](I3)
println(I6: i1 &: I6](I4, I6 :: I3)
}
object I6 {
def I3(I5: I6[I2, I3[Iterator, I6]]) = I2(I6)
case class I4[+I6](I2: I6[I4])
class i1(val I3: Int) extends I6[I2]
case class I4(I6: Seq[Any]) extends I3[Int]
}
package i0
package I4 {
object i1 extends i0
object I4 {
def I2: Int = {
val I3 = (0: Int) =>
I3
case (5, I6) => ???)((i0 / 10) i1 < 0)
def I3[@specialized I3, I6](I6: String, I5: I6, I6: I6[i1, Int, Boolean]) = I6.isInstanceOf[I6] }
def I3[I6] = (I3, I6, I6)) match { case Nothing => I6 }
}
}