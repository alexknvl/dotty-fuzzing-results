object I0 {
trait i1 extends I0
sealed trait I4 {
type I4 <: I4
type I4[I4 <: I4[I4]] <: I4[I4, I4]
trait I4 {
type I4 <: I4.I4
type i1[I4[I4 <: I4]]? <: I4;
trait I4 extends I4[String] with I4[this] import reflect.i1.I4[I4] val i1 = 1 val I3 = new I4[I4 with I4] trait I3[I4] extends I4[I4] object I2 {}
case class i1(I4: Int)(private val i1: Int) {
var i1 = _
}
implicit val i1 = I2 protected {
val I4 = new I4
def i1[I4[_]](I4: i1[I4]): I4[_]
}