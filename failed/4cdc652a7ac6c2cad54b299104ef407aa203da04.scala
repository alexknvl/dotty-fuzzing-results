trait i0 {
type I1[-i3 <: Singleton] <: i3[i3]
sealed trait i3[i3 <: I1[i3]] <: i3
class i3[i3]
case class i3(i3: Int)
object i3 {
def i3(i3: i0 { type i3[i3] = Array[i3] })#i3] = null
def i3[I1](i3: i0[I1]): I1
def i3[i3] = ???
val I1: i3#i3 = i3
def I1: i3 = ki0(new i3[I1, I1.type]: i3[I1] _*I1 with I1[i3] with i3[String, i3]
type i3[I1[+i3]]
def i3[i3[_], I1]] =
(new I1 i3 i3 i3 I1 i3 I1[i3](i3: i3 =>
List())
def i3[i3, i3](I2: I1, i3: i3) = i3
val I2: i3[String] = i3[i3, i3]
object i3 extends i3[I1] with i0[i3, i3] with i3 {
val i3 = implicitly[i3] }