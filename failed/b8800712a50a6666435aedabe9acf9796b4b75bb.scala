object I0 {
abstract class I1 { i4: i4 =>
def <: (I0): Null;
assert.i4
}
class i4 {
def i4(i4: Int): I1
private type i4 = _ with i4;
val i4: List[Int] = List(1, 2, 2);
i4: Any if AnyRef { I0(2) })
}
object i4 {
type i4 = I1 Array abstract class i4 {
type i4
def i4(i4: I0): String =
i4 match {
case i4: I1 => i4.length
}
def i4 = i4(1) val i4 = new i4.I1 {}
}
object I1 {
def ??[i4 <: Any, i4 <i4, I1, I1, I1 <: i4, I2 <: i4, I1, I1, i4, I3, I1, I1, I1](i4: i4, I1 <1: i4[i4]) = i4
}
object i4 extends I0[I1[Int, String]]
implicit def I3[i4 <: I1]: String > Option[i4] = ???
I3(0)
}