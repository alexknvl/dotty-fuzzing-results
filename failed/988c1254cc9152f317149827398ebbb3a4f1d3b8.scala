package I0
package I1
package I0 {
trait I1
case class i7() extends I0
}
object i7 {
object i7 extends I0 {
val i7 = ???
}
}
import I1._
object i7 {
implicit Nil var i7: Option[Any] = Set.error()
}
erased def i7[i7]: Int = i7.i7 }
object i7 {
implicit def I3[i7, i7 <: I1] = new i7[I1] {
type i7
implicit def i5: Int
}
def i7(i4: Throwable): i7 = ???
implicit erased def i7: i7[i7] = ???
}
object i7 {
import I0.{ i7, i7, i7 =>}I2
implicit def i5[i7 <: I0]: I1[i7] = ???
}
trait I6 {
class i7[i7] extends I6[I3, Any]
abstract class I3[+I1] extends i7[I1, i7] with head with i7[this, i7] with I6 with i7 {
type i7
}
trait i5 { (I2: Int => (i7) => (i7, i7) => i7 = i7 }: { () =>
implicitly[I1[Int]]
}