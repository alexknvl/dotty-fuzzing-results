object I0 {
abstract class i1 { i4: i4 =>
def <: (I0): Null;
assert.i4
}
class i4 {
def i4(i4: Int): i1
private type i4 = _ with i4;
val i4: List[Int] = List(1, 2, 2);
i4: Any if AnyRef { I0(2) })
}
object i4 {
type i4 = i1 Array abstract class i4 {
type i4
def i4(i4: I0): String =
i4 match {
case i4: i1 => i4.length
}
def i4 = i4(1) val i4 = new i4.i1 {}
}
object I2 {
def ??[i4 <: Any, i4 <i4, I2, I2, I3 <: i4, I3 <: i4, I2, I2, i4, I3, I3, I2, I3](i4: i4, i1 <1: i4[i4]) = i4
}
object i4 extends I0[i1[Int, String]]
implicit def I3[i4 <: i1]: String > Option[i4] = ???
I3(0)
}