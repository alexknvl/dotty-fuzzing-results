class I0
object I1 {
implicit def main(I0: Array[String]): Unit = {
this.I1()(2) match {
case i8 => 0 => I1
case I1: List[Int] => ()
}
def i8(i8: Int) = i8 match {
case I0(i8) => +
}
def main(i8: Array[String]): Unit =
List(new AnyRef)
new I1[Int]() {}
new I0() {}
}
object i8 {
type i8 = super.type
var i8: String;
def I1[i8 <: i8](implicit i8: i8, i8: i8.i8): i8.i8 = i8 + i8 })
I3: i8.head
}
implicit class I4[I1](val i8: I0) extends I0
object I7 {
def this[I1](i2: Int) = 0
def i8[i8](I4: I0[String, String]): I1[Int] = i2 match {
case I1(i8) => (i8(i8: @extends _*) => _)
case _ => Some(I5)
}
}
abstract class i2[+i8](i8: => String, i8: scala.Double[i8]) {
def i2[_](i2: => i8): i8.i8[I0] = new I0(10)
val I5 = new I0[Int].i8(i2 = 1) }
object i2 {
(i8(new I1(Array(0, 0)) forSome { List(i8, I3, I4) { i8.i8 } println(1) yield I3{
val I5 = List(i8, map, i8 => i6)
case i8(I4) => println(i8: Int) match {
case i8(i8) => i8
println( + i8)
}
}