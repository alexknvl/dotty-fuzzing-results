object I0 {
def i1[i6](i6: String)(i6: => i6): Unit = ()
def i6[i1, i6, i6[i1]](i6: i1[i6]): i6[i6] = new i6[i6] {
def i6(i6: i6): i6 = null
def i6[i6[_[_]]]](i6: i6[i6]): i6[i6]
}
class i6(val i6: Int, i1: String) {}
case class i6[i6, i6](i1: i6) extends i6[i6, i1, i1[i6]] {
def i5: i6[i3] = i3(1, i6))
println(i5 += null)
def I2 = new i1 with I2 => null
val i5 = Some (i6, i1) = I2 += i6 match {
case _: I0[i6] => i6.head
}
}
sealed iterator object i6 }
trait i6[i1] extends i1[i6]
trait i5[+i6, +i6] {
def i6: i6[i6] = new i1[i6]
sealed trait i6 { type i6[i6] }
type i6 = i6 { type i6[i6] = i6[i6] }: Any = this <: I2 map i6 yield i6 i5 : i6 =>
def i4: String => Double
}
trait i5 {
type i6
}
trait i6 {
type i1[i6] = (Int, map: Int)
lazy val i6: I0[Int] = i3
}
package i6 {
import i1.{ implicitly => } }
}