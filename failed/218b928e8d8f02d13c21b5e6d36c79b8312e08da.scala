trait I0 {
trait I0 {
type I3 <: I3
}
abstract class I3 {
type I3
type I3 <: I3 {
type I0 <: I3
}
def I3 = 0
val I3: I0
object I3
}
object I3 extends I0
object I3 {
import I0.I3.{ I3 =>
object I3.I3.I3
}
}
class I3 {
implicit def main() = I3 match {
case 1 => val I3 = I0
}
implicit def I0 = I0
sealed class I2 {
def i1(): Unit = {
println()
extends object type I3 extends I3
}
trait I0 { type I3 }
trait I3[I3, I3 <: I3 { type I0 }
type I3 <: I3.I3
type I3[I3, I3] = I3[I0]
type I0[I3]
}
trait i1 extends I3 {
type I0 <: I0
}
trait I3[I3]
trait I3[I3, I3 <: I3, I3 <: I3[I3, I3]] {
val I3: I3
type I3 <: I3[I3] <: I0[I3]
val I0: I3[Int] = I0[Int]
}