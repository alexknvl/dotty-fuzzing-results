object I0 {
trait I0 extends I0
sealed trait I1 {
type I1 <: I1
type I1[I1 <: I1[I1]] <: I1[I1, I1]
trait I1 {
type I1 <: I1.I1
type I0[I1[I1 <: I1]]? <: I1;
trait I1 extends I1[String] with I1[this] import reflect.I0.I1[I1] val I0 = 1 val I1 = new I1[I1 with I1] trait I1[I1] extends I1[I1] object I1 {}
case class I0(I1: Int)(private val I0: Int) {
var I0 = _
}
implicit val I0 = I1 protected {
val I1 = new I1
def I0[I1[_]](I1: I0[I1]): I1[_]
}