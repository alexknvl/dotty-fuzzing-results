object i0 {
trait i1 extends i0
sealed trait i2 {
type i2 <: i2
type i2[i2 <: i2[i2]] <: i2[i2, i2]
trait i2 {
type i2 <: i2.i2
type i2[i2[i2 <: i2]]? <: i2;
trait i2 extends i2[String] with i2[this] import reflect.i2.i2[i2] val i1 = 1 val i2 = new i2[i2 with i2] trait i2[i2] extends i2[i2] object i2 {}
case class i2(i2: Int)(private val i1: Int) {
var i1 = _
}
implicit val i2 = i2 protected {
val i2 = new i2
def i1[i2[_]](i2: i1[i2]): i2[_]
}