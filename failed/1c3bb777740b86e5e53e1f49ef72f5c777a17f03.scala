trait I0[+I1[_], I7[I7] <- I7[I1]]: I0[Option]] {}
trait I7[I1]
object I7 {
abstract class I1 {
type I7[I7]
def I7[I7, I7 <: I1] = new I7[I7]
}
implicit def I7[I7](I7: I7): I7.I7[String] = I7[I1]
def I7(I7: Array[I7]): Unit
}
class I1 extends I7 {
case object I1 extends I7[I0[Int]]
object i5 extends I7[I1] object I7 extends I7[Any, I7]
case class i3[I7[I6] extends AnyVal {
trait i5 {
type I1
protected[I1](implicit I7 <= I2 <: I7) extends I2[I7];
case class i3() extends I7[I1, I7]
object I4 {
implicit val I2 = (new I1)
}
val I4 = I7 {
lazy val I2 = 10
I1 match {
case I7(Some(_)) => 10
}
}
I2: I7[I7] {
def selectDynamic[i5: I7](I7: I7 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I1 {
def I2[@specialized(Int) I7](I7: I7)(I2: I7[I1]) = I7(I7)
}