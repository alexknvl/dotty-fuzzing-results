object I0 {
abstract class I0 { I5: I5 =>
def <: (I0): Null;
assert.I5
}
class I5 {
def I5(I5: Int): I0
private type I5 = _ with I5;
val I5: List[Int] = List(1, 2, 2);
I5: Any if AnyRef { I0(2) })
}
object I5 {
type I5 = I0 Array abstract class I5 {
type I5
def I5(I5: I0): String =
I5 match {
case I5: I0 => I5.length
}
def I5 = I5(1) val I5 = new I5.I0 {}
}
object I0 {
def ??[I5 <: Any, I5 <I5, I0, I0, I2 <: I5, i3 <: I5, I0, i1, I5, I5, I2, I0, I2](I5: I5, I0 <1: I5[I5]) = I5
}
object I5 extends I0[I0[Int, String]]
implicit def I5[I5 <: I0]: String > Option[I5] = ???
i4(0)
}