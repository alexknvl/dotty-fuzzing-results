object i0 {
def i0[I4](I4: String)(I4: => I4): Unit = ()
def I4[i0, I4, I4[i0]](I4: i0[I4]): I4[I4] = new I4[I4] {
def I4(I4: I4): I4 = null
def I4[I4[_[_]]]](I4: I4[I4]): I4[I4]
}
class I4(val I4: Int, i0: String) {}
case class I4[I4, I4](i0: I4) extends I4[I4, i0, i0[I4]] {
def I4: I4[I2] = I2(1, I4))
println(I4 += null)
def i1 = new i0 with i1 => null
val I4 = Some (I4, i0) = i1 += I4 match {
case _: i0[I4] => I4.head
}
}
sealed iterator object I4 }
trait I4[i0] extends i0[I4]
trait I4[+I4, +I4] {
def I4: I4[I4] = new i0[I4]
sealed trait I4 { type I4[I4] }
type I4 = I4 { type I4[I4] = I4[I4] }: Any = this <: i1 map I4 yield I4 I4 : I4 =>
def I3: String => Double
}
trait I4 {
type I4
}
trait I4 {
type i0[I4] = (Int, map: Int)
lazy val I4: i0[Int] = I2
}
package I4 {
import i0.{ implicitly => } }
}