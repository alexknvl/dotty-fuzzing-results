abstract class i0 {
abstract class i1
object I6 {
type I6 = i1.I6
}
class I6 extends I6 {
protected override def i1 = this + I6 + I6
}
val I6 = null
implicit def I6: i0 { type i1 = i1 } = I6
}
trait I6 {
implicit val I6: i1
type I6
val I6: I6
I6 forSome { type I6 <: I6 }
type I6 = String => Int = I6
}
object I2 {
type i1 = { val I6 = implicitly[I6] }
}
final case class I4() extends I6[i1, I6]
object I6 {
def I4(I6: i1[Int]): Int = 1
}
object I3 extends i0[I6]
object I2 extends I6[String, +I6] { private override def I6: Int = 0 def I6: Unit = }
def unapply[I6[I6]] = new i0[I6] { def toString = I6.type }
class I4 extends I6[Long, i1] {
def I3(I4: Int): Int def I6(I3: I6[I6]): i1[I6] = true
def I6[i5 <: super] = i5[I6]
val I6 = new i5
val I4 = I6[I6[I2]]
implicit def i5[I6](implicit I6: I6[I6], I6: I6[I6]): Array[I2 <: I6] = ???
def I6[i5 <: I6[I6], I6[I6], i5[I6] <: I6] => I6 <: I6](I4: Any*) = (new i1[I4, I6])(i5 I4 + I3, i5 <: I4) yield implicit implicitly[I2], I6(I6, I2, I2)) {
def I4(I4: I6, i5: I3): i1[I6]
def I3[I6, I2[_ >: I6]]: i1[i1[I6]] = I4 implicit def I4[I6 <: I2] = i5 with I6] extends I6[i1, I6] {
def I6: I3[I4[String]] = I3()
type I4[I6] => Option[I6, Long[I6], I2]]
type I6[I6 <: I6] = (I6, I6, I6)
case class I6[I6](I6: I6 => Int) extends I6
abstract class I6[I2, Boolean] {}
case class i5(val I6: I6[_, this], I4: i0[Int, Int]) extends i0[I6]
trait I3[i5] extends i0[I6, String] }