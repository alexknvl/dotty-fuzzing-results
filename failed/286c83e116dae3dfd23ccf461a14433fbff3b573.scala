abstract class I0 {
abstract class i1
object i5 {
type i5 = i1.i5
}
class i5 extends i5 {
protected override def i1 = this + i5 + i5
}
val i5 = null
implicit def i5: I0 { type i1 = i1 } = i5
}
trait i5 {
implicit val i5: i1
type i5
val i5: i5
i5 forSome { type i5 <: i5 }
type i5 = String => Int = i5
}
object I2 {
type i1 = { val i5 = implicitly[i5] }
}
final case class i3() extends i5[i1, i5]
object i5 {
def i3(i5: i1[Int]): Int = 1
}
object i3 extends I0[i5]
object I2 extends i5[String, +i5] { private override def i5: Int = 0 def i5: Unit = }
def unapply[i5[i5]] = new I0[i5] { def toString = i5.type }
class i3 extends i5[Long, i1] {
def i3(i3: Int): Int def i5(i3: i5[i5]): i1[i5] = true
def i5[I4 <: super] = I4[i5]
val i5 = new I4
val i3 = i5[i5[I2]]
implicit def I4[i5](implicit i5: i5[i5], i5: i5[i5]): Array[I2 <: i5] = ???
def i5[I4 <: i5[i5], i5[i5], I4[i5] <: i5] => i5 <: i5](i3: Any*) = (new i1[i3, i5])(I4 i3 + i3, I4 <: i3) yield implicit implicitly[I2], i5(i5, I2, I2)) {
def i3(i3: i5, I4: i3): i1[i5]
def i3[i5, I2[_ >: i5]]: i1[i1[i5]] = i3 implicit def i3[i5 <: I2] = I4 with i5] extends i5[i1, i5] {
def i5: i3[i3[String]] = i3()
type i3[i5] => Option[i5, Long[i5], I2]]
type i5[i5 <: i5] = (i5, i5, i5)
case class i5[i5](i5: i5 => Int) extends i5
abstract class i5[I2, Boolean] {}
case class I4(val i5: i5[_, this], i3: I0[Int, Int]) extends I0[i5]
trait i3[I4] extends I0[i5, String] }