trait I0[+I0[_], i3[i3] <- i3[I0]]: I0[Option]] {}
trait i3[I0]
object i3 {
abstract class I0 {
type i3[i3]
def i3[i3, i3 <: I0] = new i3[i3]
}
implicit def i3[i3](i3: i3): i3.i3[String] = i3[I0]
def i3(i3: Array[i3]): Unit
}
class I0 extends i3 {
case object I0 extends i3[I0[Int]]
object i1 extends i3[I0] object i3 extends i3[Any, i3]
case class I0[i3[I2] extends AnyVal {
trait i1 {
type I0
protected[I0](implicit i3 <= I0 <: i3) extends I0[i3];
case class I0() extends i3[I0, i3]
object I0 {
implicit val I0 = (new I0)
}
val I0 = i3 {
lazy val I0 = 10
I0 match {
case i3(Some(_)) => 10
}
}
I0: i3[i3] {
def selectDynamic[i1: i3](i3: i3 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I0 {
def I0[@specialized(Int) i3](i3: i3)(I0: i3[I0]) = i3(i3)
}