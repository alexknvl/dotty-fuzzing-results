object I0 {
trait I0 extends I0
sealed trait I3 {
type I3 <: I3
type I3[I3 <: I3[I3]] <: I3[I3, I3]
trait I3 {
type I3 <: I3.I3
type I1[I3[I3 <: I3]]? <: I3;
trait I3 extends I3[String] with I3[this] import reflect.I1.I3[I3] val I1 = 1 val i2 = new I3[I3 with I3] trait i2[I3] extends I3[I3] object I1 {}
case class I1(I3: Int)(private val I1: Int) {
var I1 = _
}
implicit val I1 = I1 protected {
val I3 = new I3
def I1[I3[_]](I3: I0[I3]): I3[_]
}