trait I0[+I1[_], I6[I6] <- I6[I1]]: I0[Option]] {}
trait I6[I1]
object I6 {
abstract class I1 {
type I6[I6]
def I6[I6, I6 <: I1] = new I6[I6]
}
implicit def I6[I6](I6: I6): I6.I6[String] = I6[I1]
def I6(I6: Array[I6]): Unit
}
class I2 extends I6 {
case object I2 extends I6[I0[Int]]
object I5 extends I6[I1] object I6 extends I6[Any, I6]
case class i3[I6[I6] extends AnyVal {
trait I5 {
type I2
protected[I1](implicit I6 <= i3 <: I6) extends i3[I6];
case class i3() extends I6[I1, I6]
object I4 {
implicit val i3 = (new I1)
}
val I4 = I6 {
lazy val i3 = 10
I2 match {
case I6(Some(_)) => 10
}
}
i3: I6[I6] {
def selectDynamic[I5: I6](I6: I6 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I2 {
def i3[@specialized(Int) I6](I6: I6)(i3: I6[I2]) = I6(I6)
}