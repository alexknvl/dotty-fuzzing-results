trait i0 {
trait i0 {
type i2 <: i2
}
abstract class i2 {
type i2
type i2 <: i2 {
type i0 <: i2
}
def i2 = 0
val i2: i0
object i2
}
object i2 extends i0
object i2 {
import i0.i2.{ i2 =>
object i2.i2.i2
}
}
class i2 {
implicit def main() = i2 match {
case 1 => val i2 = i1
}
implicit def i1 = i0
sealed class i1 {
def i1(): Unit = {
println()
extends object type i2 extends i2
}
trait i1 { type i2 }
trait i2[i2, i2 <: i2 { type i0 }
type i2 <: i2.i2
type i2[i2, i2] = i2[i0]
type i1[i2]
}
trait i1 extends i2 {
type i0 <: i0
}
trait i2[i2]
trait i2[i2, i2 <: i2, i2 <: i2[i2, i2]] {
val i2: i2
type i2 <: i2[i2] <: i0[i2]
val i0: i2[Int] = i0[Int]
}