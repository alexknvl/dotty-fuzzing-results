trait I0 {
type I0[-I4 <: Singleton] <: I4[I4]
sealed trait I4[I4 <: I0[I4]] <: I4
class I4[I4]
case class I4(I4: Int)
object I4 {
def I4(I4: I0 { type I4[I4] = Array[I4] })#I4] = null
def I4[I0](I4: I0[I0]): I0
def I2[I3] = ???
val I0: I4#I4 = I4
def I0: I4 = kI0(new I4[I0, I0.type]: I4[I0] _*I0 with I0[I4] with I4[String, I4]
type I4[I0[+I4]]
def I4[I4[_], i1]] =
(new I0 I3 I4 I4 I0 I2 I0[I3](I4: I4 =>
List())
def I2[I4, I4](I2: I0, I2: I4) = I2
val I2: I4[String] = I4[I4, I4]
object I2 extends I4[I0] with I0[I4, I4] with I4 {
val I4 = implicitly[I4] }