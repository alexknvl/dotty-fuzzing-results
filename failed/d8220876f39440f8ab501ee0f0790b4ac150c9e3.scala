object i0 {
def i1[I6](I6: String)(I6: => I6): Unit = ()
def I6[i1, I6, I6[i1]](I6: i1[I6]): I6[I6] = new I6[I6] {
def I6(I6: I6): I6 = null
def I6[I6[_[_]]]](I6: I6[I6]): I6[I6]
}
class I6(val I6: Int, i1: String) {}
case class I6[I6, I6](i1: I6) extends I6[I6, i1, i1[I6]] {
def i4: I6[I2] = I2(1, I6))
println(i4 += null)
def I2 = new i1 with I2 => null
val i4 = Some (I6, i1) = I2 += I6 match {
case _: i0[I6] => I6.head
}
}
sealed iterator object I6 }
trait I6[i1] extends i1[I6]
trait i4[+I6, +I6] {
def I6: I6[I6] = new i1[I6]
sealed trait I6 { type I6[I6] }
type I6 = I6 { type I6[I6] = I6[I6] }: Any = this <: I2 map I6 yield I6 I5 : I6 =>
def i3: String => Double
}
trait I5 {
type I6
}
trait I6 {
type i1[I6] = (Int, map: Int)
lazy val I6: i0[Int] = I2
}
package I6 {
import i1.{ implicitly => } }
}