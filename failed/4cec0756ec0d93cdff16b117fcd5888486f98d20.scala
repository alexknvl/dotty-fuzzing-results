package I0
package i1
package I0 {
trait i1
case class i5() extends I0
}
object i5 {
object i5 extends I0 {
val i5 = ???
}
}
import i1._
object i5 {
implicit Nil var i5: Option[Any] = Set.error()
}
erased def i5[i5]: Int = i5.i5 }
object i5 {
implicit def i2[i5, i5 <: i1] = new i5[i1] {
type i5
implicit def I4: Int
}
def i5(I3: Throwable): i5 = ???
implicit erased def i5: i5[i5] = ???
}
object i5 {
import I0.{ i5, i5, i5 =>}i2
implicit def I4[i5 <: I0]: i1[i5] = ???
}
trait I4 {
class i5[i5] extends I4[i2, Any]
abstract class I3[+i1] extends i5[i1, i5] with head with i5[this, i5] with I4 with i5 {
type i5
}
trait I4 { (i2: Int => (i5) => (i5, i5) => i5 = i5 }: { () =>
implicitly[i1[Int]]
}