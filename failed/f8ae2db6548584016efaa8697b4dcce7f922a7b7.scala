object i0 {
type i0
type i1 <: i0
val i1: i0
}
abstract class i1 extends i1 {
private var i0 = new i0.i1.i1
val i1: i0 = i1
def i1 = new i0
}
object i1 {
import i0.{ i0, i0, i1, i0 }
type i1 = i1 { type i0 <: i1.type }
type i0 <: i1
type i1 = i1.type
val i1 = i0
val i0 = i0
val i0: Symbol = new i0
val i1 = Seq with i0
val i0 = i1
val i0 = new i0
val i1 = new i1
val i0 = i0
val i1 = new i1
(null: i1) match {
case _: i0 => println
}
case class i0(i1: Int)
implicit val i1: Int = 42
def i0(): Unit =
new i0 + i1
}
implicit class i1 {
val i0 = new i1('i1)
}
package i0;
abstract class i1 {
def i1(): Int = 5
def i1: Any = ???
val i0: Int = ???
}
object i0 {
def i0(i1: Int) = i0 match { case _ => i0 })
}