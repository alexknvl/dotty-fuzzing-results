trait i0 {
type i0
type :+:[I6[I6
1 <: I6[I6]], I6]
[Symbol, i0[_]]
][I6]
trait I6 { def main(I6: Array[String]): Unit =
for (i0 <- I6.I6) = 1;
def I6(I6: i0): i0[I6] =
if (true) Some(true)
new I6[Int, Int]
I6((I6, I6)): i0[I6] = I6
}
new I6 {
type I6 = { type I6[I6] <: i0[I6] }
}
object I6 {
import i0.{ Set, I6 =>
type I6 = String }
I6
def I6[I6]: I6 = I6
I6
}
}
trait I2 extends I6 {
val i0: I6.type = I6.type;
def i0(I2: Any) = I6 ++ I2;
def I6[I6](i3: Any) = I6: I6[I6]()
val I1: I6 = null
def I6 =
val I6 = I6(I6 )
def i0 = I6(5) {
val i5 = I6[Dynamic[i0[Int]] def I6[I6, i4](i0: => I6, I6: I6[I6, I6]): (0 => I6) => i0[Int, Int, Int, Int] = (I6 => (I6: Any)) (i4, I6, i0 +/ I2, i0))
@inline def i0[I6](I6: I6, I2: I6): Array[I6] = I6
def i0(I6: String = ): Unit = {}
i0.I6 = 42 match {
case I6[@specialized(scala.None) def i0(implicit I1: I6[I2]): Seq[Int] = ???
import I2._
def I1 = .0
}