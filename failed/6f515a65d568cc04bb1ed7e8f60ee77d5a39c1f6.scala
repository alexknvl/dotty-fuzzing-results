object i0 {
abstract class i0[i0]
case class I1[i0]()
}
final class i2 extends i0 {
type i0[+i0] <: i0[i0] <: i0[I1]
def i2[i2 <: i0[i2]]: i0[i2] = i2[i0]
def i3[i3 <: i0[i2]](i3: i0): i3[i3 #: i2] = i3 match {
case _: i0 => i3.i0(i3)
case _ => None
case i0(i3) => i2
}
def i3[i2 <: List[i2]](i3: i3[i2]): i0[I1] =
i3.i3.collect(
i3 = 0)
case _ => sys.error("")
new i2[Int](10)
}
val i3: i0[Int] = null
}