object i0 {
type I1
type i3 <: i0
val i3: I1
}
abstract class i3 extends i3 {
private var i0 = new I1.i3.i3
val i3: i0 = i3
def i3 = new i0
}
object i3 {
import i0.{ I1, I2, i3, I2 }
type i3 = i3 { type I1 <: i3.type }
type I2 <: i3
type i3 = i3.type
val i3 = I2
val I2 = I2
val I2: Symbol = new I2
val i3 = Seq with I2
val I2 = i3
val I2 = new I2
val i3 = new i3
val I2 = I2
val i3 = new i3
(null: i3) match {
case _: I2 => println
}
case class I2(i3: Int)
implicit val i3: Int = 42
def I2(): Unit =
new I1 + i3
}
implicit class i3 {
val I2 = new i3('i3)
}
package i0;
abstract class i3 {
def i3(): Int = 5
def i3: Any = ???
val I2: Int = ???
}
object i0 {
def I1(i3: Int) = I1 match { case _ => I2 })
}