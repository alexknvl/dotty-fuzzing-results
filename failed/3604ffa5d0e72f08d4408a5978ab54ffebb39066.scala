trait i0[+i0[_], I2[I2] <- I2[i0]]: i0[Option]] {}
trait I2[i0]
object I2 {
abstract class i0 {
type I2[I2]
def I2[I2, I2 <: i0] = new I2[I2]
}
implicit def I2[I2](I2: I2): I2.I2[String] = I2[i0]
def I2(I2: Array[I2]): Unit
}
class I1 extends I2 {
case object I1 extends I2[i0[Int]]
object I2 extends I2[i0] object I2 extends I2[Any, I2]
case class I1[I2[I2] extends AnyVal {
trait I2 {
type I1
protected[i0](implicit I2 <= I1 <: I2) extends I1[I2];
case class I1() extends I2[i0, I2]
object I1 {
implicit val I1 = (new i0)
}
val I1 = I2 {
lazy val I1 = 10
I1 match {
case I2(Some(_)) => 10
}
}
I1: I2[I2] {
def selectDynamic[I2: I2](I2: I2 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I1 {
def I1[@specialized(Int) I2](I2: I2)(I1: I2[I1]) = I2(I2)
}