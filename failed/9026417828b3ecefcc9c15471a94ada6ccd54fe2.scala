object i0 {
type i1
type i3 <: i0
val i3: i1
}
abstract class i3 extends i3 {
private var i0 = new i1.i3.i3
val i3: i0 = i3
def i3 = new i0
}
object i3 {
import i0.{ i1, I2, i3, I2 }
type i3 = i3 { type i1 <: i3.type }
type i1 <: i3
type i3 = i3.type
val i3 = I2
val I2 = i1
val i1: Symbol = new I2
val i3 = Seq with i1
val I2 = i3
val i1 = new I2
val i3 = new i3
val I2 = I2
val i3 = new i3
(null: i3) match {
case _: i1 => println
}
case class i1(i3: Int)
implicit val i3: Int = 42
def I2(): Unit =
new i1 + i3
}
implicit class i3 {
val i1 = new i3('i3)
}
package i0;
abstract class i3 {
def i3(): Int = 5
def i3: Any = ???
val I2: Int = ???
}
object i0 {
def i1(i3: Int) = i1 match { case _ => i1 })
}