object i0 {
def I1[I7](I7: String)(I7: => I7): Unit = ()
def I7[I1, I7, I7[I1]](I7: I1[I7]): I7[I7] = new I7[I7] {
def I7(I7: I7): I7 = null
def I7[I7[_[_]]]](I7: I7[I7]): I7[I7]
}
class I7(val I7: Int, I1: String) {}
case class I7[I7, I7](I1: I7) extends I7[I7, I1, I1[I7]] {
def I5: I7[i3] = i3(1, I7))
println(I5 += null)
def i2 = new I1 with i2 => null
val I5 = Some (I7, I1) = i2 += I7 match {
case _: i0[I7] => I7.head
}
}
sealed iterator object I7 }
trait I7[I1] extends I1[I7]
trait I5[+I7, +I7] {
def I7: I7[I7] = new I1[I7]
sealed trait I7 { type I7[I7] }
type I7 = I7 { type I7[I7] = I7[I7] }: Any = this <: i2 map I7 yield I7 i6 : I7 =>
def I4: String => Double
}
trait i6 {
type I7
}
trait I7 {
type I1[I7] = (Int, map: Int)
lazy val I7: i0[Int] = i3
}
package I7 {
import I1.{ implicitly => } }
}