trait I0 {
type I0[-i2 <: Singleton] <: i2[i2]
sealed trait i2[i2 <: I0[i2]] <: i2
class i2[i2]
case class i2(i2: Int)
object i2 {
def i2(i2: I0 { type i2[i2] = Array[i2] })#i2] = null
def i2[I0](i2: I0[I0]): I0
def I1[i2] = ???
val I1: i2#i2 = i2
def I1: i2 = kI0(new i2[I0, I1.type]: i2[I0] _*I1 with I0[i2] with i2[String, i2]
type i2[I0[+i2]]
def i2[i2[_], I1]] =
(new I1 i2 i2 i2 I0 I1 I1[i2](i2: i2 =>
List())
def I1[i2, i2](I1: I0, I1: i2) = I1
val I1: i2[String] = i2[i2, i2]
object I1 extends i2[I0] with I0[i2, i2] with i2 {
val i2 = implicitly[i2] }