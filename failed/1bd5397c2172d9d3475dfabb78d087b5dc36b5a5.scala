package object `package` {
class List[+i0] extends I1[I3](I3: Some[Long, i0[I1])
class I3[I1](I1: => Int) extends i0[I3]
case class var[I1] extends I3[Boolean]
object I1 extends I3
case class I3[I3](I3: Int) extends i0[I3]
class I3[I3 <: I3[I3]](val I1: I3) extends I3[I3];
case class I1[+I1, +I3] extends I3[(I1, I3] { type I3 {}
object I1 {
def map[I3[I3 <: I3] <: I3]: I3[I3]
}
trait I3[+I3, +I3 <: AnyRef] extends App {
type I1[I3 <: I3] <: I3[I3, I3]
def I3[+I1] (val I3: I3): I3
type I3[I1]
final case class I1(I3: I3) extends I1[I3]
class i0[I1[_], I3]
implicit case Stream[I1] = I1(new I3[I3], I3)
def protected[I1](I3: I1, I1: i0): Int = 5I1
def I1[I1, I3 <: I1[I3]](I3: I3[I3], I1: I3[I3, I3], I1: I1[I1[I3, I1]]): Unit
implicit protected[I3](I1);
new i2.I3[I3.I3] Any
case object I1 extends I3[I3] case class I3[I3](I3: I3)
case object I3 extends I3[Nothing] {
type I3[I3] = I1[Int]
type I3 = I1
class I1 extends I3[I3] {
def I1 = new I3
val I3: I3[I1,_, Int, Int] = null
}
class I1 extends i0[Int] {
def I3(I3: Int, I3: Int = 0)(I3: (= I3): i0[I3, I3], I3 => this.I3, I3[I3]]) =
this, I3.I3[I3.I3](((I3, I3)) == new I3[I3]()).List(5)
def I3(I3: Any) = ()
@I1(16)
def I3[I1, I3](I3: I1[I3, I3)]) = I3 I3 I3 else I1(I3) }
}
}