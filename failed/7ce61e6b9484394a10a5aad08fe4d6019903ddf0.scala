trait i0[+I1[_], I6[I6] <- I6[I1]]: i0[Option]] {}
trait I6[I1]
object I6 {
abstract class I1 {
type I6[I6]
def I6[I6, I6 <: I1] = new I6[I6]
}
implicit def I6[I6](I6: I6): I6.I6[String] = I6[I1]
def I6(I6: Array[I6]): Unit
}
class I2 extends I6 {
case object I2 extends I6[i0[Int]]
object I5 extends I6[I1] object I6 extends I6[Any, I6]
case class i4[I6[I6] extends AnyVal {
trait I5 {
type I2
protected[I1](implicit I6 <= I3 <: I6) extends I3[I6];
case class i4() extends I6[I1, I6]
object I5 {
implicit val I3 = (new I1)
}
val I5 = I6 {
lazy val I3 = 10
I2 match {
case I6(Some(_)) => 10
}
}
I3: I6[I6] {
def selectDynamic[I5: I6](I6: I6 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I2 {
def I3[@specialized(Int) I6](I6: I6)(I3: I6[I2]) = I6(I6)
}