class i0 {
class I1
trait I3 extends I1
abstract class I3 {
type I3[_ <: Traversable[this.I3, I3]] <: I3[I1]
for (I3 < next)
val I1: String => I3.I3;
trait I3 {
type I3 <: I3;
abstract class I3() extends I3
val I1 = I3()
val I1 = new I3().I1() }
class I1 extends I3[I3](val i2: i0#I3) {
def I3: I3 = null;
val i2: I3.I3 = new I3;
val I1 = new I3 ({ val I3: Int; var I1 = '42 }
class I3 {
def I1(): Unit
def I1(): Unit = () I3 I1 implicit val I1 = I1
val I1 =  match { case I1(_) => I3 }
def I3(): Unit = ();
def I1(I3: String) = I3
}
val I1 = new I3[I1, I3](I1)
class I3 extends I3 { def I3 = 0 }
}
trait I3 {
implicit val I1: I3 = _
def I1(I1: => Int = ()) = I1
I3
override type I3 = I3[I3]
type I1[+I3] <: i0[I1] <: I3[I1, I3]](I1: Int => I3): Any =
(I3, I3) match {
case None: I1[List, Int] => Some(I1, head else new I3)
}
}