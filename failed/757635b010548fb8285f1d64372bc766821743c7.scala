object I0 {
type I0
type I1 <: I0
val I1: I0
}
abstract class I1 extends I1 {
private var I0 = new I0.I1.I1
val I1: I0 = I1
def I1 = new I0
}
object I1 {
import I0.{ I0, I0, I1, I0 }
type I1 = I1 { type I0 <: I1.type }
type I0 <: I1
type I1 = I1.type
val I1 = I0
val I1 = I0
val I0: Symbol = new I1
val I1 = Seq with I0
val I0 = I1
val I0 = new I1
val I1 = new I1
val I0 = I0
val I1 = new I1
(null: I1) match {
case _: I0 => println
}
case class I0(I1: Int)
implicit val I1: Int = 42
def I0(): Unit =
new I0 + I1
}
implicit class I1 {
val I0 = new I1('I1)
}
package I0;
abstract class I1 {
def I1(): Int = 5
def I1: Any = ???
val I1: Int = ???
}
object I0 {
def I0(I1: Int) = I0 match { case _ => I0 })
}