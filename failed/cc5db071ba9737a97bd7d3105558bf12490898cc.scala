object i0 {
type i1
type I4 <: i0
val I4: i1
}
abstract class I4 extends I4 {
private var i0 = new i1.I4.I4
val I4: i0 = I4
def I4 = new i0
}
object I4 {
import i0.{ i1, I3, I4, I3 }
type I4 = I4 { type i1 <: I4.type }
type i1 <: I4
type I4 = I4.type
val I4 = i2
val I3 = i1
val i2: Symbol = new I3
val I4 = Seq with i1
val I3 = I4
val i2 = new I3
val I4 = new I4
val I3 = i2
val I4 = new I4
(null: I4) match {
case _: i1 => println
}
case class i1(I4: Int)
implicit val I3: Int = 42
def I3(): Unit =
new i1 + I4
}
implicit class I4 {
val i1 = new I4('I4)
}
package i0;
abstract class I4 {
def I4(): Int = 5
def I4: Any = ???
val I3: Int = ???
}
object i0 {
def i1(I4: Int) = i1 match { case _ => i2 })
}