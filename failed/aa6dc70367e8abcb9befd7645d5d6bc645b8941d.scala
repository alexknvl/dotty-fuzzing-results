object i0 {
type I1
type i4 <: i0
val i4: I1
}
abstract class i4 extends i4 {
private var i0 = new I1.i4.i4
val i4: i0 = i4
def i4 = new i0
}
object i4 {
import i0.{ I1, i3, i4, i3 }
type i4 = i4 { type I1 <: i4.type }
type I1 <: i4
type i4 = i4.type
val i4 = i3
val i3 = I1
val i2: Symbol = new i3
val i4 = Seq with I1
val i3 = i4
val i2 = new i3
val i4 = new i4
val i3 = i3
val i4 = new i4
(null: i4) match {
case _: I1 => println
}
case class I1(i4: Int)
implicit val i4: Int = 42
def i3(): Unit =
new I1 + i4
}
implicit class i4 {
val I1 = new i4('i4)
}
package i0;
abstract class i4 {
def i4(): Int = 5
def i4: Any = ???
val i3: Int = ???
}
object i0 {
def I1(i4: Int) = I1 match { case _ => i2 })
}