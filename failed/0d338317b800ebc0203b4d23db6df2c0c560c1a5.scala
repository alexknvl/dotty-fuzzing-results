package I0
package i1
package I0 {
trait i1
case class I3() extends I0
}
object I3 {
object I3 extends I0 {
val I3 = ???
}
}
import i1._
object I3 {
implicit Nil var I3: Option[Any] = Set.error()
}
erased def I3[I3]: Int = I3.I3 }
object I3 {
implicit def i1[I3, I3 <: i1] = new I3[i1] {
type I3
implicit def i2: Int
}
def I3(i2: Throwable): I3 = ???
implicit erased def I3: I3[I3] = ???
}
object I3 {
import I0.{ I3, I3, I3 =>}i1
implicit def i2[I3 <: I0]: i1[I3] = ???
}
trait I3 {
class I3[I3] extends I3[i1, Any]
abstract class i2[+i1] extends I3[i1, I3] with head with I3[this, I3] with I3 with I3 {
type I3
}
trait i2 { (i1: Int => (I3) => (I3, I3) => I3 = I3 }: { () =>
implicitly[i1[Int]]
}