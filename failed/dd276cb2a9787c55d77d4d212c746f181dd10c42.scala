object i0 {
abstract class I1 { I8: I8 =>
def <: (i0): Null;
assert.I8
}
class I8 {
def I8(I8: Int): I1
private type I8 = _ with I8;
val I8: List[Int] = List(1, 2, 2);
I8: Any if AnyRef { i0(2) })
}
object I8 {
type I8 = I1 Array abstract class I8 {
type I8
def I8(I8: i0): String =
I8 match {
case I8: I1 => I8.length
}
def I8 = I8(1) val I8 = new I8.I1 {}
}
object i2 {
def ??[I8 <: Any, I8 <I8, i2, i2, I4 <: I8, I5 <: I8, i2, i3, I8, I7, I4, i2, I4](I8: I8, I1 <1: I8[I8]) = I8
}
object I8 extends i0[I1[Int, String]]
implicit def I7[I8 <: I1]: String > Option[I8] = ???
i6(0)
}