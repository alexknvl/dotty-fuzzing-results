trait i0 {
type i0[-I5 <: Singleton] <: I5[I5]
sealed trait I5[I5 <: i0[I5]] <: I5
class I5[I5]
case class I5(I5: Int)
object I5 {
def I5(I5: i0 { type I5[I5] = Array[I5] })#I5] = null
def I5[I1](I5: i0[i0]): I1
def I3[I4] = ???
val I1: I5#I5 = I5
def I1: I5 = ki0(new I5[i0, I1.type]: I5[i0] _*I1 with i0[I5] with I5[String, I5]
type I5[i0[+I5]]
def I5[I5[_], i2]] =
(new I1 I4 I5 I5 I1 I3 I1[I4](I5: I5 =>
List())
def I3[I5, I5](i2: i0, I3: I5) = I3
val i2: I5[String] = I5[I5, I5]
object I3 extends I5[I1] with i0[I5, I5] with I5 {
val I5 = implicitly[I5] }