object i0 {
abstract class i0[i0]
case class i1[i0]()
}
final class i2 extends i0 {
type i0[+i0] <: i0[i0] <: i0[i1]
def i2[i2 <: i0[i2]]: i0[i2] = i2[i0]
def I3[I3 <: i0[i2]](I3: i0): I3[I3 #: i2] = I3 match {
case _: i0 => I3.i0(I3)
case _ => None
case i0(I3) => i2
}
def I3[i2 <: List[i2]](I3: I3[i2]): i0[i1] =
I3.I3.collect(
I3 = 0)
case _ => sys.error("")
new i2[Int](10)
}
val I3: i0[Int] = null
}