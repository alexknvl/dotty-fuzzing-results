class I0 {
class I1
trait I3 extends I1
abstract class I3 {
type I3[_ <: Traversable[this.I3, I3]] <: I3[I1]
for (I3 < next)
val I1: String => I3.I3;
trait I3 {
type I3 <: I3;
abstract class I3() extends I3
val I1 = I3()
val i2 = new I3().I1() }
class I1 extends I3[I3](val i2: I0#I3) {
def I3: I3 = null;
val i2: I3.I3 = new I3;
val i2 = new I3 ({ val I3: Int; var I1 = '42 }
class I3 {
def i2(): Unit
def i2(): Unit = () I3 i2 implicit val i2 = i2
val i2 =  match { case i2(_) => I3 }
def I3(): Unit = ();
def i2(I3: String) = I3
}
val i2 = new I3[I1, I3](I1)
class I3 extends I3 { def I3 = 0 }
}
trait I3 {
implicit val I1: I3 = _
def I1(i2: => Int = ()) = i2
I3
override type I3 = I3[I3]
type i2[+I3] <: I0[i2] <: I3[I1, I3]](i2: Int => I3): Any =
(I3, I3) match {
case None: I1[List, Int] => Some(i2, head else new I3)
}
}