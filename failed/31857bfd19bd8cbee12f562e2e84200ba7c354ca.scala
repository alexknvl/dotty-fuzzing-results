object I0 {
abstract class i1 { I4: I4 =>
def <: (I0): Null;
assert.I4
}
class I4 {
def I4(I4: Int): i1
private type I4 = _ with I4;
val I4: List[Int] = List(1, 2, 2);
I4: Any if AnyRef { I0(2) })
}
object I4 {
type I4 = i1 Array abstract class I4 {
type I4
def I4(I4: I0): String =
I4 match {
case I4: i1 => I4.length
}
def I4 = I4(1) val I4 = new I4.i1 {}
}
object i1 {
def ??[I4 <: Any, I4 <I4, i1, i1, i2 <: I4, i2 <: I4, i1, i2, I4, I3, i2, i1, i2](I4: I4, i1 <1: I4[I4]) = I4
}
object I4 extends I0[i1[Int, String]]
implicit def I3[I4 <: i1]: String > Option[I4] = ???
i2(0)
}