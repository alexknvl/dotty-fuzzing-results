object I0 {
abstract class I0[I0]
case class I1[I0]()
}
final class I1 extends I0 {
type I0[+I0] <: I0[I0] <: I0[I1]
def I1[I1 <: I0[I1]]: I0[I1] = I1[I0]
def I1[I2 <: I0[I1]](I2: I0): I2[I1 #: I1] = I1 match {
case _: I0 => I1.I0(I2)
case _ => None
case I0(I1) => I1
}
def I1[I1 <: List[I1]](I2: I1[I1]): I0[I1] =
I1.I2.collect(
I2 = 0)
case _ => sys.error("")
new I1[Int](10)
}
val I2: I0[Int] = null
}