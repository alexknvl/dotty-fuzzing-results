object i0 {
type i0
type I2 <: i0
val I2: i0
}
abstract class I2 extends I2 {
private var i0 = new i0.I2.I2
val I2: i0 = I2
def I2 = new i0
}
object I2 {
import i0.{ i0, I2, I2, I2 }
type I2 = I2 { type i0 <: I2.type }
type i1 <: I2
type I2 = I2.type
val I2 = I2
val I2 = i1
val i1: Symbol = new I2
val I2 = Seq with i1
val I2 = I2
val i1 = new I2
val I2 = new I2
val I2 = I2
val I2 = new I2
(null: I2) match {
case _: i1 => println
}
case class i1(I2: Int)
implicit val I2: Int = 42
def I2(): Unit =
new i0 + I2
}
implicit class I2 {
val i1 = new I2('I2)
}
package i0;
abstract class I2 {
def I2(): Int = 5
def I2: Any = ???
val I2: Int = ???
}
object i0 {
def i0(I2: Int) = i0 match { case _ => i1 })
}