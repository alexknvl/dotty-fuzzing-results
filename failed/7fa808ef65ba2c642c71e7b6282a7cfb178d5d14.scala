object I0 {
abstract class I1 { I6: I6 =>
def <: (I0): Null;
assert.I6
}
class I6 {
def I6(I6: Int): I1
private type I6 = _ with I6;
val I6: List[Int] = List(1, 2, 2);
I6: Any if AnyRef { I0(2) })
}
object I6 {
type I6 = I1 Array abstract class I6 {
type I6
def I6(I6: I0): String =
I6 match {
case I6: I1 => I6.length
}
def I6 = I6(1) val I6 = new I6.I1 {}
}
object I2 {
def ??[I6 <: Any, I6 <I6, I2, I2, i4 <: I6, i5 <: I6, I2, I3, I6, I6, i4, I2, i4](I6: I6, I1 <1: I6[I6]) = I6
}
object I6 extends I0[I1[Int, String]]
implicit def I6[I6 <: I1]: String > Option[I6] = ???
I6(0)
}