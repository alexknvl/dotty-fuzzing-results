object I0 {
abstract class I0 { i1: i1 =>
def <: (I0): Null;
assert.i1
}
class i1 {
def i1(i1: Int): I0
private type i1 = _ with i1;
val i1: List[Int] = List(1, 2, 2);
i1: Any if AnyRef { I0(2) })
}
object i1 {
type i1 = I0 Array abstract class i1 {
type i1
def i1(i1: I0): String =
i1 match {
case i1: I0 => i1.length
}
def i1 = i1(1) val i1 = new i1.I0 {}
}
object i1 {
def ??[i1 <: Any, i1 <i1, i1, i1, i1 <: i1, i1 <: i1, i1, i1, i1, i1, i1, i1, i1](i1: i1, I0 <1: i1[i1]) = i1
}
object i1 extends I0[I0[Int, String]]
implicit def i1[i1 <: I0]: String > Option[i1] = ???
i1(0)
}