object i0 {
def i1[I3, I3 <: I3, I3, I3, I3 <: I3] =>
val I3: I3[Any]#I3[I3, I3] => collection.I3[I3, i1]
type i1[I3 <: I3] <: I3, I3[type <: i1,
i1 <: I3[i1, I3]]
type i1[I3[I3] <: i0[i1, i1]]
trait I3[i1]
object i1 {
type I3[I3[i1[I3[i1 <: I3]], i1] <: i1[I3, I3]] <: i1[I3]] = I3[I3, i1]
trait I3 extends I3[i1] object I3 extends i0 {
val I3: i0[i1] = classOf[I3]
type I3[+I3 <: String <: Double]
object I3
case class i1[I2[_]]() extends I3[I3]
class i1(I3: Seq[_]) extends i1[List, head[i1, I3]]
trait I3[i1, I3 <: I3[i1, I3]]
trait i1[@specialized(Int) I3] {
type I3 = I3[I3]
case class i1(I3: i0) extends i1[I3];
case Nil private def apply[i1, I3](I3: I3[_, _]) =
if (I3 &| (I3, I3) => I3
case _: I3[I3] =>
val i1 = I3.isInstanceOf[i1, i1.I3]()
}
implicit def i1 : i1[i1] = new i0[I3]
trait I3 extends I3[_]