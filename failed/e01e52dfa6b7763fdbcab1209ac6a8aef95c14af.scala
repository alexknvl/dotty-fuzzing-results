trait i0 {
type i0[i1] = { def i1: i1.i1 }
type i1 = i0[Option]
val I2: i0
}
sealed trait i0 extends i0 {
trait i0[+i1, +i1] {
private[this] def I2 = false
def I2: Int = 0
}
object I2 extends App {
type I3[-I2, I2] = super.i1
}
class I2 extends I2 {
type i1
trait I3[+I2]
def flatMap[I2](I2: I2[I2]): i1[I3]
}
class I3 {
implicit def I3: I2 = new i1[I2] { }
}
object I3 {
implicitly[i0[_]]
new I2[i0[i1]]
}