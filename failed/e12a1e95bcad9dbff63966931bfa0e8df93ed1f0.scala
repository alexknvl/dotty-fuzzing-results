class I0 {
class I1
trait I3 extends I1
abstract class I3 {
type I3[_ <: Traversable[this.I3, I3]] <: I3[I1]
for (I3 < next)
val I1: String => I3.I3;
trait I3 {
type I3 <: I3;
abstract class I3() extends I3
val I1 = I3()
val I2 = new I3().I1() }
class I1 extends I3[I3](val I3: I0#I3) {
def I3: I3 = null;
val I3: I3.I3 = new I3;
val I2 = new I3 ({ val I3: Int; var I1 = '42 }
class I3 {
def I2(): Unit
def I2(): Unit = () I3 I2 implicit val I2 = I2
val I2 =  match { case I2(_) => I3 }
def I3(): Unit = ();
def I2(I3: String) = I3
}
val I2 = new I3[I1, I3](I1)
class I3 extends I3 { def I3 = 0 }
}
trait I3 {
implicit val I1: I3 = _
def I1(I2: => Int = ()) = I2
I3
override type I3 = I3[I3]
type I2[+I3] <: I0[I2] <: I3[I1, I3]](I2: Int => I3): Any =
(I3, I3) match {
case None: I1[List, Int] => Some(I2, head else new I3)
}
}