object i0 {
trait i0 extends i0
sealed trait i2 {
type i2 <: i2
type i2[i2 <: i2[i2]] <: i2[i2, i2]
trait i2 {
type i2 <: i2.i2
type i0[i2[i2 <: i2]]? <: i2;
trait i2 extends i2[String] with i2[this] import reflect.i0.i2[i2] val i0 = 1 val I1 = new i2[i2 with i2] trait I1[i2] extends i2[i2] object I1 {}
case class i0(i2: Int)(private val i0: Int) {
var i0 = _
}
implicit val i0 = I1 protected {
val i2 = new i2
def i0[i2[_]](i2: i0[i2]): i2[_]
}