object i0 {
trait I1 extends i0
sealed trait i3 {
type i3 <: i3
type i3[i3 <: i3[i3]] <: i3[i3, i3]
trait i3 {
type i3 <: i3.i3
type i2[i3[i3 <: i3]]? <: i3;
trait i3 extends i3[String] with i3[this] import reflect.i2.i3[i3] val I1 = 1 val i3 = new i3[i3 with i3] trait i3[i3] extends i3[i3] object i2 {}
case class i2(i3: Int)(private val I1: Int) {
var I1 = _
}
implicit val i2 = i2 protected {
val i3 = new i3
def I1[i3[_]](i3: I1[i3]): i3[_]
}