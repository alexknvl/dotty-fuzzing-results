class I0(I0: Any)
class I2 {
implicit def I0(I2: I2): I2.I2 = this
}
class I2(val I0: I0) {}
abstract class I2 {
override def I0(): I0 = I2;
}
{
def I0(): Any = I2()
def I0(I2: Int*) = 1
println(I2)
List(this: Any) new toString
List
class I0[+I2] { def apply(I2: AnyRef) = I2 match { case _: String => println(); () }
{ val I2 = new I2(1)
}
I0: I2 < 2
I2 = new {
def I0[I0 >: Null <: String <: reflect.ClassTag]() = this.I2(Int @@ _ => I2)
}
}
object I2 extends I0
object I2 {
@final var I2: String = super[I0.I2]
implicit def I2(I2: I2.I2): Boolean = 8
def I2[I0](I2: I0)(implicit I0: I0[String]) = I2
}
class I1 extends I0[Int] { def I0: Int = 0 }
class I0 { (I2: Int) => { Some((I2, I2)~ => case List(1, this, I2) })
class I2[I0 with I2, I0, I0](I1: I2) extends I0[I0, Int]#I1[I2]
val I1: I2[_] = Stream.I2(I1)
}