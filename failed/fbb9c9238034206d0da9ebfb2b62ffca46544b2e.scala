object i0 {
type I1
type I5 <: i0
val I5: I1
}
abstract class I5 extends I5 {
private var i0 = new I1.I5.I5
val I5: i0 = I5
def I5 = new i0
}
object I5 {
import i0.{ I1, I5, I5, I5 }
type I5 = I5 { type I1 <: I5.type }
type I2 <: I5
type I5 = I5.type
val I5 = i4
val I5 = I2
val I3: Symbol = new I5
val I5 = Seq with I2
val I5 = I5
val I3 = new I5
val I5 = new I5
val I5 = i4
val I5 = new I5
(null: I5) match {
case _: I2 => println
}
case class I2(I5: Int)
implicit val I5: Int = 42
def I5(): Unit =
new I1 + I5
}
implicit class I5 {
val I2 = new I5('I5)
}
package i0;
abstract class I5 {
def I5(): Int = 5
def I5: Any = ???
val I5: Int = ???
}
object i0 {
def I1(I5: Int) = I1 match { case _ => I3 })
}