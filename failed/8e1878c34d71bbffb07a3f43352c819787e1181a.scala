final String { type I1 }) =
sealed abstract class I0[I2]
final case class I2(I2: Int) extends I0(I2)
case class I2() extends I0[I2]
object I2 {
type I2[I2 <: I2[I2], I2[_], I2] <: I1[I1], I2 <: I2, I2 <: I2]
type I2 <: I1
type I0[_] = I1
type I2[I2] = PartialFunction[I1, I1]
!= I2
def I2[I2[_]](I2: List[I2]): I1[Int] | I2[I2]
I2 :: Equiv[I2]
val I1 = I2[I2]
val I1 = new I2[I2]
}
class I2 {
def I1 = new I2
}
class I1 extends I0[List, I2] {}
trait I0 {
def Console: Array[I1]
}