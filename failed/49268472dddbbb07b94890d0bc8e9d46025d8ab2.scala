package object `package` {
class List[+I0] extends I0[I2](I2: Some[Long, I0[I0])
class I2[I0](I0: => Int) extends I0[I2]
case class var[I0] extends I2[Boolean]
object I0 extends I2
case class I2[I2](I2: Int) extends I0[I2]
class I2[I2 <: I2[I2]](val I0: I2) extends I2[I2];
case class I1[+I0, +I2] extends I2[(I1, I2] { type I2 {}
object I0 {
def map[I2[I2 <: I2] <: I2]: I2[I2]
}
trait I2[+I2, +I2 <: AnyRef] extends App {
type I0[I2 <: I2] <: I2[I2, I2]
def I2[+I0] (val I2: I2): I2
type I2[I0]
final case class I0(I2: I2) extends I0[I2]
class I0[I0[_], I2]
implicit case Stream[I0] = I0(new I2[I2], I2)
def protected[I0](I2: I0, I0: I0): Int = 5I1
def I0[I0, I2 <: I0[I2]](I2: I2[I2], I1: I2[I2, I2], I0: I0[I0[I2, I0]]): Unit
implicit protected[I2](I0);
new I2.I2[I2.I2] Any
case object I0 extends I2[I2] case class I2[I2](I2: I2)
case object I2 extends I2[Nothing] {
type I2[I2] = I0[Int]
type I2 = I0
class I0 extends I2[I2] {
def I0 = new I2
val I2: I2[I0,_, Int, Int] = null
}
class I0 extends I0[Int] {
def I2(I2: Int, I2: Int = 0)(I2: (= I2): I0[I2, I2], I2 => this.I2, I2[I2]]) =
this, I2.I2[I2.I2](((I2, I2)) == new I2[I2]()).List(5)
def I2(I2: Any) = ()
@I0(16)
def I2[I0, I2](I2: I0[I2, I2)]) = I2 I2 I2 else I1(I2) }
}
}