object i0 {
type I1
type i7 <: i0
val i7: I1
}
abstract class i7 extends i7 {
private var i0 = new I1.i7.i7
val i7: i0 = i7
def i7 = new i0
}
object i7 {
import i0.{ I1, i5, i7, i5 }
type i7 = i7 { type I1 <: i7.type }
type I2 <: i7
type i7 = i7.type
val i7 = I4
val i6 = I2
val I3: Symbol = new i6
val i7 = Seq with I2
val i5 = i7
val I3 = new i6
val i7 = new i7
val i5 = I4
val i7 = new i7
(null: i7) match {
case _: I2 => println
}
case class I2(i7: Int)
implicit val i7: Int = 42
def i5(): Unit =
new I1 + i7
}
implicit class i7 {
val I2 = new i7('i7)
}
package i0;
abstract class i7 {
def i7(): Int = 5
def i7: Any = ???
val i6: Int = ???
}
object i0 {
def I1(i7: Int) = I1 match { case _ => I3 })
}