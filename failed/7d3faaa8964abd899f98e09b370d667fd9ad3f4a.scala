object i0 {
trait i0 extends i0
sealed trait I3 {
type I3 <: I3
type I3[I3 <: I3[I3]] <: I3[I3, I3]
trait I3 {
type I3 <: I3.I3
type i1[I3[I3 <: I3]]? <: I3;
trait I3 extends I3[String] with I3[this] import reflect.i1.I3[I3] val i1 = 1 val i2 = new I3[I3 with I3] trait i2[I3] extends I3[I3] object i2 {}
case class i1(I3: Int)(private val i0: Int) {
var i0 = _
}
implicit val i1 = i2 protected {
val I3 = new I3
def i0[I3[_]](I3: i0[I3]): I3[_]
}