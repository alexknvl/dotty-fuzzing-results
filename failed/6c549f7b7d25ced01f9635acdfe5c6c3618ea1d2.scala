trait I0 {
type I1[-i5 <: Singleton] <: i5[i5]
sealed trait i5[i5 <: I1[i5]] <: i5
class i5[i5]
case class i5(i5: Int)
object i5 {
def i5(i5: I0 { type i5[i5] = Array[i5] })#i5] = null
def i5[i2](i5: I0[I1]): i2
def I4[i5] = ???
val i2: i5#i5 = i5
def i2: i5 = kI0(new i5[I1, i2.type]: i5[I1] _*i2 with I1[i5] with i5[String, i5]
type i5[I1[+i5]]
def i5[i5[_], i3]] =
(new i2 i5 i5 i5 i2 I4 i2[i5](i5: i5 =>
List())
def I4[i5, i5](i3: I1, I4: i5) = I4
val i3: i5[String] = i5[i5, i5]
object I4 extends i5[i2] with I0[i5, i5] with i5 {
val i5 = implicitly[i5] }