trait I0[+I1[_], I1[I1] <- I1[I1]]: I0[Option]] {}
trait I1[I1]
object I1 {
abstract class I1 {
type I1[I1]
def I1[I1, I1 <: I1] = new I1[I1]
}
implicit def I1[I1](I1: I1): I1.I1[String] = I1[I1]
def I1(I1: Array[I1]): Unit
}
class I1 extends I1 {
case object I1 extends I1[I0[Int]]
object I1 extends I1[I1] object I1 extends I1[Any, I1]
case class I1[I1[I1] extends AnyVal {
trait I1 {
type I1
protected[I1](implicit I1 <= I1 <: I1) extends I1[I1];
case class I1() extends I1[I1, I1]
object I1 {
implicit val I1 = (new I1)
}
val I1 = I1 {
lazy val I1 = 10
I1 match {
case I1(Some(_)) => 10
}
}
I1: I1[I1] {
def selectDynamic[I1: I1](I1: I1 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I1 {
def I1[@specialized(Int) I1](I1: I1)(I1: I1[I1]) = I1(I1)
}