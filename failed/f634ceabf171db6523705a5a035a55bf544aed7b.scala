object I0 {
type I0
type I2 <: I0
val I2: I0
}
abstract class I2 extends I2 {
private var I0 = new I0.I2.I2
val I2: I0 = I2
def I2 = new I0
}
object I2 {
import I0.{ I0, I1, I2, I1 }
type I2 = I2 { type I0 <: I2.type }
type I0 <: I2
type I2 = I2.type
val I2 = I0
val I1 = I0
val I0: Symbol = new I1
val I2 = Seq with I0
val I1 = I2
val I0 = new I1
val I2 = new I2
val I1 = I0
val I2 = new I2
(null: I2) match {
case _: I0 => println
}
case class I0(I2: Int)
implicit val I2: Int = 42
def I1(): Unit =
new I0 + I2
}
implicit class I2 {
val I0 = new I2('I2)
}
package I0;
abstract class I2 {
def I2(): Int = 5
def I2: Any = ???
val I1: Int = ???
}
object I0 {
def I0(I2: Int) = I0 match { case _ => I0 })
}