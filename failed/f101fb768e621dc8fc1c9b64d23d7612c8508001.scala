object i0 {
type I1
type i2 <: i0
val i2: I1
}
abstract class i2 extends i2 {
private var i0 = new I1.i2.i2
val i2: i0 = i2
def i2 = new i0
}
object i2 {
import i0.{ I1, I1, i2, I1 }
type i2 = i2 { type I1 <: i2.type }
type I1 <: i2
type i2 = i2.type
val i2 = I1
val I1 = I1
val I1: Symbol = new I1
val i2 = Seq with I1
val I1 = i2
val I1 = new I1
val i2 = new i2
val I1 = I1
val i2 = new i2
(null: i2) match {
case _: I1 => println
}
case class I1(i2: Int)
implicit val I1: Int = 42
def I1(): Unit =
new I1 + i2
}
implicit class i2 {
val I1 = new i2('i2)
}
package i0;
abstract class i2 {
def i2(): Int = 5
def i2: Any = ???
val I1: Int = ???
}
object i0 {
def I1(i2: Int) = I1 match { case _ => I1 })
}