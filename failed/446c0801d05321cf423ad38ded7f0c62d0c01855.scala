object I0 {
type i1
type i5 <: I0
val i5: i1
}
abstract class i5 extends i5 {
private var I0 = new i1.i5.i5
val i5: I0 = i5
def i5 = new I0
}
object i5 {
import I0.{ i1, i4, i5, i4 }
type i5 = i5 { type i1 <: i5.type }
type I2 <: i5
type i5 = i5.type
val i5 = i4
val i4 = I2
val I3: Symbol = new i4
val i5 = Seq with I2
val i4 = i5
val I3 = new i4
val i5 = new i5
val i4 = i4
val i5 = new i5
(null: i5) match {
case _: I2 => println
}
case class I2(i5: Int)
implicit val i4: Int = 42
def i4(): Unit =
new i1 + i5
}
implicit class i5 {
val I2 = new i5('i5)
}
package I0;
abstract class i5 {
def i5(): Int = 5
def i5: Any = ???
val i4: Int = ???
}
object I0 {
def i1(i5: Int) = i1 match { case _ => I3 })
}