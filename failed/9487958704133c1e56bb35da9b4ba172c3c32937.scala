object I0 {
type I0
type I3 <: I0
val I3: I0
}
abstract class I3 extends I3 {
private var I0 = new I0.I3.I3
val I3: I0 = I3
def I3 = new I0
}
object I3 {
import I0.{ I0, i2, I3, i2 }
type I3 = I3 { type I0 <: I3.type }
type i1 <: I3
type I3 = I3.type
val I3 = i1
val I3 = i1
val i1: Symbol = new I3
val I3 = Seq with i1
val i2 = I3
val i1 = new I3
val I3 = new I3
val i2 = i1
val I3 = new I3
(null: I3) match {
case _: i1 => println
}
case class i1(I3: Int)
implicit val I3: Int = 42
def i2(): Unit =
new I0 + I3
}
implicit class I3 {
val i1 = new I3('I3)
}
package I0;
abstract class I3 {
def I3(): Int = 5
def I3: Any = ???
val I3: Int = ???
}
object I0 {
def I0(I3: Int) = I0 match { case _ => i1 })
}