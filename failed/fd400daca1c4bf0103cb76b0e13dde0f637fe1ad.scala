object I0 {
type I0
type i2 <: I0
val i2: I0
}
abstract class i2 extends i2 {
private var I0 = new I0.i2.i2
val i2: I0 = i2
def i2 = new I0
}
object i2 {
import I0.{ I0, i2, i2, i2 }
type i2 = i2 { type I0 <: i2.type }
type i1 <: i2
type i2 = i2.type
val i2 = i1
val i2 = i1
val i1: Symbol = new i2
val i2 = Seq with i1
val i2 = i2
val i1 = new i2
val i2 = new i2
val i2 = i1
val i2 = new i2
(null: i2) match {
case _: i1 => println
}
case class i1(i2: Int)
implicit val i2: Int = 42
def i2(): Unit =
new I0 + i2
}
implicit class i2 {
val i1 = new i2('i2)
}
package I0;
abstract class i2 {
def i2(): Int = 5
def i2: Any = ???
val i2: Int = ???
}
object I0 {
def I0(i2: Int) = I0 match { case _ => i1 })
}