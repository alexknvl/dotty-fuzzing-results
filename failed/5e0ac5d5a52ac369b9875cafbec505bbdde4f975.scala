object i0 {
trait I1 {
val I6: Int = 1
}
abstract class I6 {
trait I6 {
type I6
}
trait I6 extends I6 with I6 {
object I1 extends super.I6
}
}
trait I6[+I6]
final case class I6[I6](val I6: I6[I6], I6: I6[i0])
object I6 {
type I1 <: I6
final lazy object I4
def I4[I4](I6: Stream[I5]): I4 <: I6 { type i2 <: I6.I6 }
implicit def I1[I6](implicit I6: I6[I6#I6]) =
I4 match {
case None =>
val I4 = I6[I6]
val I4: i0[Int, Int] = i3(List(), implicitly[I6]);
()
}
new I6 {
println(I6(5)) match {
case map(_) =>
case None => ???
}
}
}
trait I1[@specialized i3, I6, -I6, i2]] {
def I6[I6[_]: I6[I6]](I6: I1
@+ I6 = this
}
}
object I1 I6 {
val I6(I6) = ???
val I6: () = ???
val I6 = new I6[I6] {}
}
package I1 {
object i3 extends I6[Double, I1]
object i2 extends i0[I6, I6] {
val I6: i0[Int, Nothing] = new Array[I6]
def I1[I1](i2: I6[I1] => I6[I6 => I6]: I6[I6 <: I6]) =
try I6.collect.Byte = I6
}
}
object I6 {
type I6[I6]
}
final object I1 {
def I6 = new I6[I6] def I1[I6: specialized, I6[I6 <: I6[I6]]]: i0[I6, I6] => I6] = (??? : I6)]
type I1 = I6#I1
}
object I1 {
def main(i0: Array[String]): Unit = {}
}
object I1 extends I6[head](head) extends I1[this] {
val I6: I6[String] = new i0().I1(I6) = 1.0
val I6 = new i0(10. 2: Int[Int]]
println(I6"")
}
}
}