object I0 {
abstract class i1 { i5: i5 =>
def <: (I0): Null;
assert.i5
}
class i5 {
def i5(i5: Int): i1
private type i5 = _ with i5;
val i5: List[Int] = List(1, 2, 2);
i5: Any if AnyRef { I0(2) })
}
object i5 {
type i5 = i1 Array abstract class i5 {
type i5
def i5(i5: I0): String =
i5 match {
case i5: i1 => i5.length
}
def i5 = i5(1) val i5 = new i5.i1 {}
}
object i2 {
def ??[i5 <: Any, i5 <i5, i2, i2, I3 <: i5, I4 <: i5, i2, I3, i5, i5, I3, i2, I3](i5: i5, i1 <1: i5[i5]) = i5
}
object i5 extends I0[i1[Int, String]]
implicit def i5[i5 <: i1]: String > Option[i5] = ???
i5(0)
}