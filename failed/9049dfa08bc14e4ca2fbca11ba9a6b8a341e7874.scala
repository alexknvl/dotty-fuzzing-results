package I0
package i1
package I0 {
trait i1
case class i5() extends I0
}
object i5 {
object i5 extends I0 {
val i5 = ???
}
}
import i1._
object i5 {
implicit Nil var i5: Option[Any] = Set.error()
}
erased def i5[i5]: Int = i5.i5 }
object i5 {
implicit def I3[i5, i5 <: i1] = new i5[i1] {
type i5
implicit def i5: Int
}
def i5(i5: Throwable): i5 = ???
implicit erased def i5: i5[i5] = ???
}
object i5 {
import I0.{ i5, i5, i5 =>}I2
implicit def i5[i5 <: I0]: i1[i5] = ???
}
trait i5 {
class i5[i5] extends i5[I3, Any]
abstract class i4[+i1] extends i5[i1, i5] with head with i5[this, i5] with i5 with i5 {
type i5
}
trait i5 { (I2: Int => (i5) => (i5, i5) => i5 = i5 }: { () =>
implicitly[i1[Int]]
}