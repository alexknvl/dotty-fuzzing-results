trait I0 {
type i1[-I5 <: Singleton] <: I5[I5]
sealed trait I5[I5 <: i1[I5]] <: I5
class I5[I5]
case class I5(I5: Int)
object I5 {
def I5(I5: I0 { type I5[I5] = Array[I5] })#I5] = null
def I5[I2](I5: I0[i1]): I2
def I5[I5] = ???
val I2: I5#I5 = I5
def I2: I5 = kI0(new I5[i1, I2.type]: I5[i1] _*I2 with i1[I5] with I5[String, I5]
type I5[i1[+I5]]
def I5[I5[_], i3]] =
(new I2 I5 I5 I5 I2 I5 I2[I5](I5: I5 =>
List())
def I5[I5, I5](i4: i1, I5: I5) = I5
val i4: I5[String] = I5[I5, I5]
object I5 extends I5[I2] with I0[I5, I5] with I5 {
val I5 = implicitly[I5] }