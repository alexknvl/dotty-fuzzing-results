trait i0 {
trait i1 {
type I2 <: I2
}
abstract class I2 {
type I2
type I2 <: I2 {
type i1 <: I2
}
def I2 = 0
val I2: i0
object I2
}
object I2 extends i0
object I2 {
import i0.I2.{ I2 =>
object I2.I2.I2
}
}
class I2 {
implicit def main() = I2 match {
case 1 => val I2 = i1
}
implicit def i1 = i1
sealed class I2 {
def i1(): Unit = {
println()
extends object type I2 extends I2
}
trait i1 { type I2 }
trait I2[I2, I2 <: I2 { type i1 }
type I2 <: I2.I2
type I2[I2, I2] = I2[i1]
type i1[I2]
}
trait i1 extends I2 {
type i1 <: i0
}
trait I2[I2]
trait I2[I2, I2 <: I2, I2 <: I2[I2, I2]] {
val I2: I2
type I2 <: I2[I2] <: i0[I2]
val i1: I2[Int] = i1[Int]
}