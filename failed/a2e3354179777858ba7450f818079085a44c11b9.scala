package i0
package I1
package i0 {
trait I1
case class i5() extends i0
}
object i5 {
object i5 extends i0 {
val i5 = ???
}
}
import I1._
object i5 {
implicit Nil var i5: Option[Any] = Set.error()
}
erased def i5[i5]: Int = i5.i5 }
object i5 {
implicit def i2[i5, i5 <: I1] = new i5[I1] {
type i5
implicit def I3: Int
}
def i5(I3: Throwable): i5 = ???
implicit erased def i5: i5[i5] = ???
}
object i5 {
import i0.{ i5, i5, i5 =>}I1
implicit def I3[i5 <: i0]: I1[i5] = ???
}
trait i4 {
class i5[i5] extends i4[i2, Any]
abstract class i2[+I1] extends i5[I1, i5] with head with i5[this, i5] with i4 with i5 {
type i5
}
trait I3 { (I1: Int => (i5) => (i5, i5) => i5 = i5 }: { () =>
implicitly[I1[Int]]
}