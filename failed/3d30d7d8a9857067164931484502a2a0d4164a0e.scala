trait i0 {
type i1[-I5 <: Singleton] <: I5[I5]
sealed trait I5[I5 <: i1[I5]] <: I5
class I5[I5]
case class I5(I5: Int)
object I5 {
def I5(I5: i0 { type I5[I5] = Array[I5] })#I5] = null
def I5[i1](I5: i0[i1]): i1
def i3[I4] = ???
val i1: I5#I5 = I5
def i1: I5 = ki0(new I5[i1, i1.type]: I5[i1] _*i1 with i1[I5] with I5[String, I5]
type I5[i1[+I5]]
def I5[I5[_], i2]] =
(new i1 I4 I5 I5 i1 i3 i1[I4](I5: I5 =>
List())
def i3[I5, I5](i3: i1, i3: I5) = i3
val i3: I5[String] = I5[I5, I5]
object i3 extends I5[i1] with i0[I5, I5] with I5 {
val I5 = implicitly[I5] }