object I0 {
def I1[i4](i4: String)(i4: => i4): Unit = ()
def i4[I1, i4, i4[I1]](i4: I1[i4]): i4[i4] = new i4[i4] {
def i4(i4: i4): i4 = null
def i4[i4[_[_]]]](i4: i4[i4]): i4[i4]
}
class i4(val i4: Int, I1: String) {}
case class i4[i4, i4](I1: i4) extends i4[i4, I1, I1[i4]] {
def I3: i4[I3] = I3(1, i4))
println(I3 += null)
def I2 = new I1 with I2 => null
val I3 = Some (i4, I1) = I2 += i4 match {
case _: I0[i4] => i4.head
}
}
sealed iterator object i4 }
trait i4[I1] extends I1[i4]
trait I3[+i4, +i4] {
def i4: i4[i4] = new I1[i4]
sealed trait i4 { type i4[i4] }
type i4 = i4 { type i4[i4] = i4[i4] }: Any = this <: I2 map i4 yield i4 i4 : i4 =>
def I3: String => Double
}
trait i4 {
type i4
}
trait i4 {
type I1[i4] = (Int, map: Int)
lazy val i4: I0[Int] = I3
}
package i4 {
import I1.{ implicitly => } }
}