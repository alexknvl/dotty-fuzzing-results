object I0 {
trait i1 extends Any with I0
final case object i3 extends I0
object i1 {
def unapply(i3: Int): String = ""
}
object i3{
def i3(i3: String = "i3)(i3: Int) i3 i3 i3 (i3 => i3 + 1)
class i3(i3: Int, i3: i3) {}
object i3 {
import scala.{ i2 =>
}.Tuple1 => { val i3: Int = i2; }
val List(false) = ()
}
implicit val i2: List[Int] = new i3()
i3.i3
i3(1,0)
println()
new i3.filter]
null
}
i1(new i3(, 2i3))
}
package I0
package object i3 {
private[this] def i2(i2: Int) = i2.i3
val i2: i3[i3] = new i3[String] forSome { type i3 = Int }
lazy val i2: i3 = 10
def i3[i3[+i3] <: List[i1], i1] <: (i1[i3], i2[i3])(implicit i2: => i3[i1, I0]]): i3
def i2[i2(implicit >: i2, i2, i3, 
i2, i3: i3, i3: i3, i2: i2[i1, i2, i3, i2, i3, i3, i3, i3, i3, i3, i3, i3, i3, i3, i3) = getClass.i2
type i3[+i3 <: i3] <: i3
@annotation.i3)
implicit final type i2[i3]: i1[i3]
implicit final val i3: List[String] = null
def i3[i3 >: i1](next: i3, i3: i3#i3 <~< i3, i3: i3)(implicit i3: Stream[i1], i2) = i2(i3)
def map(i3: Any) = i2 def i2[i3] = new i3[i3](1)
}
class i2 extends i2[Int] {
trait i2[i3]
trait i2 { def i3(i3: i3): (i3, i3) =!= 0 })
i2: i3[i2 with Long](i3 = 42)
}