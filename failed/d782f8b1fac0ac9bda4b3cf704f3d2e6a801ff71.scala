object I0 {
type I0
type i3 <: I0
val i3: I0
}
abstract class i3 extends i3 {
private var I0 = new I0.i3.i3
val i3: I0 = i3
def i3 = new I0
}
object i3 {
import I0.{ I0, i3, i3, i3 }
type i3 = i3 { type I0 <: i3.type }
type I1 <: i3
type i3 = i3.type
val i3 = i3
val i3 = I1
val I2: Symbol = new i3
val i3 = Seq with I1
val i3 = i3
val I2 = new i3
val i3 = new i3
val i3 = i3
val i3 = new i3
(null: i3) match {
case _: I1 => println
}
case class I1(i3: Int)
implicit val i3: Int = 42
def i3(): Unit =
new I0 + i3
}
implicit class i3 {
val I1 = new i3('i3)
}
package I0;
abstract class i3 {
def i3(): Int = 5
def i3: Any = ???
val i3: Int = ???
}
object I0 {
def I0(i3: Int) = I0 match { case _ => I2 })
}