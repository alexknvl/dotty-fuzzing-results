object i0 {
abstract class I1 { i6: i6 =>
def <: (i0): Null;
assert.i6
}
class i6 {
def i6(i6: Int): I1
private type i6 = _ with i6;
val i6: List[Int] = List(1, 2, 2);
i6: Any if AnyRef { i0(2) })
}
object i6 {
type i6 = I1 Array abstract class i6 {
type i6
def i6(i6: i0): String =
i6 match {
case i6: I1 => i6.length
}
def i6 = i6(1) val i6 = new i6.I1 {}
}
object I2 {
def ??[i6 <: Any, i6 <i6, I2, I2, I4 <: i6, I4 <: i6, I2, I3, i6, i6, I4, I2, I4](i6: i6, I1 <1: i6[i6]) = i6
}
object i6 extends i0[I1[Int, String]]
implicit def i6[i6 <: I1]: String > Option[i6] = ???
I5(0)
}