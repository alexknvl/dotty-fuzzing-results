object I0 {
abstract class i1 { i6: i6 =>
def <: (I0): Null;
assert.i6
}
class i6 {
def i6(i6: Int): i1
private type i6 = _ with i6;
val i6: List[Int] = List(1, 2, 2);
i6: Any if AnyRef { I0(2) })
}
object i6 {
type i6 = i1 Array abstract class i6 {
type i6
def i6(i6: I0): String =
i6 match {
case i6: i1 => i6.length
}
def i6 = i6(1) val i6 = new i6.i1 {}
}
object i2 {
def ??[i6 <: Any, i6 <i6, i2, i2, I4 <: i6, i5 <: i6, i2, I3, i6, i6, I4, i2, I4](i6: i6, i1 <1: i6[i6]) = i6
}
object i6 extends I0[i1[Int, String]]
implicit def i6[i6 <: i1]: String > Option[i6] = ???
i5(0)
}