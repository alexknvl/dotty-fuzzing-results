trait I0[+I0[_], I3[I3] <- I3[I0]]: I0[Option]] {}
trait I3[I0]
object I3 {
abstract class I0 {
type I3[I3]
def I3[I3, I3 <: I0] = new I3[I3]
}
implicit def I3[I3](I3: I3): I3.I3[String] = I3[I0]
def I3(I3: Array[I3]): Unit
}
class I1 extends I3 {
case object I1 extends I3[I0[Int]]
object I3 extends I3[I0] object I3 extends I3[Any, I3]
case class I3[I3[I3] extends AnyVal {
trait I3 {
type I1
protected[I0](implicit I3 <= i2 <: I3) extends i2[I3];
case class I3() extends I3[I0, I3]
object I3 {
implicit val i2 = (new I0)
}
val I3 = I3 {
lazy val i2 = 10
I1 match {
case I3(Some(_)) => 10
}
}
i2: I3[I3] {
def selectDynamic[I3: I3](I3: I3 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I1 {
def i2[@specialized(Int) I3](I3: I3)(i2: I3[I1]) = I3(I3)
}