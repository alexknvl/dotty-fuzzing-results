trait I0 {
type I0[-I3 <: Singleton] <: I3[I3]
sealed trait I3[I3 <: I0[I3]] <: I3
class I3[I3]
case class I3(I3: Int)
object I3 {
def I3(I3: I0 { type I3[I3] = Array[I3] })#I3] = null
def I3[i1](I3: I0[I0]): i1
def I2[I3] = ???
val i1: I3#I3 = I3
def i1: I3 = kI0(new I3[I0, i1.type]: I3[I0] _*i1 with I0[I3] with I3[String, I3]
type I3[I0[+I3]]
def I3[I3[_], i1]] =
(new i1 I3 I3 I3 i1 I2 i1[I3](I3: I3 =>
List())
def I2[I3, I3](i1: I0, I2: I3) = I2
val i1: I3[String] = I3[I3, I3]
object I2 extends I3[i1] with I0[I3, I3] with I3 {
val I3 = implicitly[I3] }