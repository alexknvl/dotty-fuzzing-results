object I0 {
type I0
type i1 <: I0
val i1: I0
}
abstract class i1 extends i1 {
private var I0 = new I0.i1.i1
val i1: I0 = i1
def i1 = new I0
}
object i1 {
import I0.{ I0, i1, i1, i1 }
type i1 = i1 { type I0 <: i1.type }
type i1 <: i1
type i1 = i1.type
val i1 = i1
val i1 = i1
val i1: Symbol = new i1
val i1 = Seq with i1
val i1 = i1
val i1 = new i1
val i1 = new i1
val i1 = i1
val i1 = new i1
(null: i1) match {
case _: i1 => println
}
case class i1(i1: Int)
implicit val i1: Int = 42
def i1(): Unit =
new I0 + i1
}
implicit class i1 {
val i1 = new i1('i1)
}
package I0;
abstract class i1 {
def i1(): Int = 5
def i1: Any = ???
val i1: Int = ???
}
object I0 {
def I0(i1: Int) = I0 match { case _ => i1 })
}