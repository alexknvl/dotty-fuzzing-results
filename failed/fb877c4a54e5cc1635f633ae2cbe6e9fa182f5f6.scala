package object `package` {
class List[+I0] extends I1[I3](I3: Some[Long, I0[I1])
class I3[I1](I2: => Int) extends I0[I3]
case class var[I1] extends I3[Boolean]
object I1 extends I3
case class I3[I3](I3: Int) extends I0[I3]
class I3[I3 <: I3[I3]](val I1: I3) extends I3[I3];
case class I2[+I1, +I3] extends I3[(I2, I3] { type I3 {}
object I1 {
def map[I3[I3 <: I3] <: I3]: I3[I3]
}
trait I3[+I3, +I3 <: AnyRef] extends App {
type I1[I3 <: I3] <: I3[I3, I3]
def I3[+I1] (val I3: I3): I3
type I3[I1]
final case class I1(I3: I3) extends I1[I3]
class I0[I1[_], I3]
implicit case Stream[I1] = I2(new I3[I3], I3)
def protected[I1](I3: I1, I1: I0): Int = 5I2
def I1[I2, I3 <: I1[I3]](I3: I3[I3], I2: I3[I3, I3], I1: I1[I2[I3, I2]]): Unit
implicit protected[I3](I1);
new I2.I3[I3.I3] Any
case object I1 extends I3[I3] case class I3[I3](I3: I3)
case object I3 extends I3[Nothing] {
type I3[I3] = I2[Int]
type I3 = I1
class I1 extends I3[I3] {
def I1 = new I3
val I3: I3[I1,_, Int, Int] = null
}
class I1 extends I0[Int] {
def I3(I3: Int, I3: Int = 0)(I3: (= I3): I0[I3, I3], I3 => this.I3, I3[I3]]) =
this, I3.I3[I3.I3](((I3, I3)) == new I3[I3]()).List(5)
def I3(I3: Any) = ()
@I1(16)
def I3[I1, I3](I3: I1[I3, I3)]) = I3 I3 I3 else I2(I3) }
}
}