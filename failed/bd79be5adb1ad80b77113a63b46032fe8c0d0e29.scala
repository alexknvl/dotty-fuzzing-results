object I0 {
type i1
type i5 <: I0
val i5: i1
}
abstract class i5 extends i5 {
private var I0 = new i1.i5.i5
val i5: I0 = i5
def i5 = new I0
}
object i5 {
import I0.{ i1, i2, i5, i2 }
type i5 = i5 { type i1 <: i5.type }
type i2 <: i5
type i5 = i5.type
val i5 = i2
val I3 = i2
val i2: Symbol = new I3
val i5 = Seq with i2
val i2 = i5
val i2 = new I3
val i5 = new i5
val i2 = i2
val i5 = new i5
(null: i5) match {
case _: i2 => println
}
case class i2(i5: Int)
implicit val i4: Int = 42
def i2(): Unit =
new i1 + i5
}
implicit class i5 {
val i2 = new i5('i5)
}
package I0;
abstract class i5 {
def i5(): Int = 5
def i5: Any = ???
val I3: Int = ???
}
object I0 {
def i1(i5: Int) = i1 match { case _ => i2 })
}