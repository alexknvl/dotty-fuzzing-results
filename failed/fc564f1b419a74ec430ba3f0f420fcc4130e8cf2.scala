object i0 {
def I1[i4](i4: String)(i4: => i4): Unit = ()
def i4[I1, i4, i4[I1]](i4: I1[i4]): i4[i4] = new i4[i4] {
def i4(i4: i4): i4 = null
def i4[i4[_[_]]]](i4: i4[i4]): i4[i4]
}
class i4(val i4: Int, I1: String) {}
case class i4[i4, i4](I2: i4) extends i4[i4, I1, I1[i4]] {
def i4: i4[i3] = i3(1, i4))
println(i4 += null)
def I2 = new I2 with I2 => null
val i4 = Some (i4, I2) = I2 += i4 match {
case _: i0[i4] => i4.head
}
}
sealed iterator object i4 }
trait i4[I2] extends I1[i4]
trait i4[+i4, +i4] {
def i4: i4[i4] = new I1[i4]
sealed trait i4 { type i4[i4] }
type i4 = i4 { type i4[i4] = i4[i4] }: Any = this <: I2 map i4 yield i4 i4 : i4 =>
def i4: String => Double
}
trait i4 {
type i4
}
trait i4 {
type I1[i4] = (Int, map: Int)
lazy val i4: i0[Int] = i3
}
package i4 {
import I1.{ implicitly => } }
}