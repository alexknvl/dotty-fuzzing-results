trait i0 {
type i0[I1] = { def I1: I1.I1 }
type I1 = i0[Option]
val i2: i0
}
sealed trait i0 extends i0 {
trait i0[+I1, +I1] {
private[this] def i2 = false
def i2: Int = 0
}
object i2 extends App {
type i2[-i2, i2] = super.I1
}
class i2 extends i2 {
type I1
trait i2[+i2]
def flatMap[i2](i2: i2[i2]): I1[I3]
}
class i2 {
implicit def I3: i2 = new I1[i2] { }
}
object I3 {
implicitly[i0[_]]
new i2[i0[I1]]
}