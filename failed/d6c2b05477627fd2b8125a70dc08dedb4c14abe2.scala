object I0 {
abstract class I0 { I3: I3 =>
def <: (I0): Null;
assert.I3
}
class I3 {
def I3(I3: Int): I0
private type I3 = _ with I3;
val I3: List[Int] = List(1, 2, 2);
I3: Any if AnyRef { I0(2) })
}
object I3 {
type I3 = I0 Array abstract class I3 {
type I3
def I3(I3: I0): String =
I3 match {
case I3: I0 => I3.length
}
def I3 = I3(1) val I3 = new I3.I0 {}
}
object i1 {
def ??[I3 <: Any, I3 <I3, i1, i1, i1 <: I3, I2 <: I3, i1, i1, I3, I3, i1, i1, i1](I3: I3, I0 <1: I3[I3]) = I3
}
object I3 extends I0[I0[Int, String]]
implicit def I3[I3 <: I0]: String > Option[I3] = ???
I3(0)
}