object i0 {
def i0[i5](i5: String)(i5: => i5): Unit = ()
def i5[i0, i5, i5[i0]](i5: i0[i5]): i5[i5] = new i5[i5] {
def i5(i5: i5): i5 = null
def i5[i5[_[_]]]](i5: i5[i5]): i5[i5]
}
class i5(val i5: Int, i0: String) {}
case class i5[i5, i5](I1: i5) extends i5[i5, i0, i0[i5]] {
def I4: i5[I3] = I3(1, i5))
println(I4 += null)
def I2 = new I1 with I2 => null
val I4 = Some (i5, I1) = I2 += i5 match {
case _: i0[i5] => i5.head
}
}
sealed iterator object i5 }
trait i5[I1] extends i0[i5]
trait I4[+i5, +i5] {
def i5: i5[i5] = new i0[i5]
sealed trait i5 { type i5[i5] }
type i5 = i5 { type i5[i5] = i5[i5] }: Any = this <: I2 map i5 yield i5 I4 : i5 =>
def I4: String => Double
}
trait I4 {
type i5
}
trait i5 {
type i0[i5] = (Int, map: Int)
lazy val i5: i0[Int] = I3
}
package i5 {
import i0.{ implicitly => } }
}