trait I0 {
type I0[I1] = { def I1: I1.I1 }
type I1 = I0[Option]
val I2: I0
}
sealed trait I0 extends I0 {
trait I0[+I1, +I1] {
private[this] def I2 = false
def i3: Int = 0
}
object i3 extends App {
type I4[-I2, i3] = super.I1
}
class I2 extends I2 {
type I1
trait I4[+i3]
def flatMap[I2](i3: I2[I2]): I1[I4]
}
class I4 {
implicit def I4: I2 = new I1[i3] { }
}
object I4 {
implicitly[I0[_]]
new i3[I0[I1]]
}