object I0 {
type I0
type I4 <: I0
val I4: I0
}
abstract class I4 extends I4 {
private var I0 = new I0.I4.I4
val I4: I0 = I4
def I4 = new I0
}
object I4 {
import I0.{ I0, i2, I4, i2 }
type I4 = I4 { type I0 <: I4.type }
type I0 <: I4
type I4 = I4.type
val I4 = i2
val i3 = I0
val I1: Symbol = new i3
val I4 = Seq with I0
val i2 = I4
val I1 = new i3
val I4 = new I4
val i2 = i2
val I4 = new I4
(null: I4) match {
case _: I0 => println
}
case class I0(I4: Int)
implicit val I4: Int = 42
def i2(): Unit =
new I0 + I4
}
implicit class I4 {
val I0 = new I4('I4)
}
package I0;
abstract class I4 {
def I4(): Int = 5
def I4: Any = ???
val i3: Int = ???
}
object I0 {
def I0(I4: Int) = I0 match { case _ => I1 })
}