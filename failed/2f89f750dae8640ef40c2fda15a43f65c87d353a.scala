object i0 {
trait i0 extends i0
sealed trait I1 {
type I1 <: I1
type I1[I1 <: I1[I1]] <: I1[I1, I1]
trait I1 {
type I1 <: I1.I1
type i0[I1[I1 <: I1]]? <: I1;
trait I1 extends I1[String] with I1[this] import reflect.i0.I1[I1] val i0 = 1 val I1 = new I1[I1 with I1] trait I1[I1] extends I1[I1] object I1 {}
case class i0(I1: Int)(private val i0: Int) {
var i0 = _
}
implicit val i0 = I1 protected {
val I1 = new I1
def i0[I1[_]](I1: i0[I1]): I1[_]
}