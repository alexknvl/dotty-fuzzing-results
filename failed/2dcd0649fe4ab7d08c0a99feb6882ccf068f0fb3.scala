object i0 {
type i0
type i3 <: i0
val i3: i0
}
abstract class i3 extends i3 {
private var i0 = new i0.i3.i3
val i3: i0 = i3
def i3 = new i0
}
object i3 {
import i0.{ i0, I2, i3, I2 }
type i3 = i3 { type i0 <: i3.type }
type I1 <: i3
type i3 = i3.type
val i3 = I2
val I2 = I1
val I1: Symbol = new I2
val i3 = Seq with I1
val I2 = i3
val I1 = new I2
val i3 = new i3
val I2 = I2
val i3 = new i3
(null: i3) match {
case _: I1 => println
}
case class I1(i3: Int)
implicit val i3: Int = 42
def I2(): Unit =
new i0 + i3
}
implicit class i3 {
val I1 = new i3('i3)
}
package i0;
abstract class i3 {
def i3(): Int = 5
def i3: Any = ???
val I2: Int = ???
}
object i0 {
def i0(i3: Int) = i0 match { case _ => I1 })
}