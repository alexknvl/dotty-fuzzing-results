trait i0 {
trait i0 {
type I2 <: I2
}
abstract class I2 {
type I2
type I2 <: I2 {
type i0 <: I2
}
def I2 = 0
val I2: i0
object I2
}
object I2 extends i0
object I2 {
import i0.I2.{ I2 =>
object I2.I2.I2
}
}
class I2 {
implicit def main() = I2 match {
case 1 => val I2 = I1
}
implicit def I1 = I1
sealed class I2 {
def I1(): Unit = {
println()
extends object type I2 extends I2
}
trait I1 { type I2 }
trait I2[I2, I2 <: I2 { type i0 }
type I2 <: I2.I2
type I2[I2, I2] = I2[I1]
type I1[I2]
}
trait I2 extends I2 {
type i0 <: i0
}
trait I2[I2]
trait I2[I2, I2 <: I2, I2 <: I2[I2, I2]] {
val I2: I2
type I2 <: I2[I2] <: i0[I2]
val I1: I2[Int] = I1[Int]
}