trait I0[+i1[_], i5[i5] <- i5[i1]]: I0[Option]] {}
trait i5[i1]
object i5 {
abstract class i1 {
type i5[i5]
def i5[i5, i5 <: i1] = new i5[i5]
}
implicit def i5[i5](i5: i5): i5.i5[String] = i5[i1]
def i5(i5: Array[i5]): Unit
}
class i2 extends i5 {
case object i2 extends i5[I0[Int]]
object I3 extends i5[i1] object i5 extends i5[Any, i5]
case class i2[i5[I4] extends AnyVal {
trait I3 {
type i2
protected[i1](implicit i5 <= i2 <: i5) extends i2[i5];
case class i2() extends i5[i1, i5]
object i2 {
implicit val i2 = (new i1)
}
val i2 = i5 {
lazy val i2 = 10
i2 match {
case i5(Some(_)) => 10
}
}
i2: i5[i5] {
def selectDynamic[I3: i5](i5: i5 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class i2 {
def i2[@specialized(Int) i5](i5: i5)(i2: i5[i2]) = i5(i5)
}