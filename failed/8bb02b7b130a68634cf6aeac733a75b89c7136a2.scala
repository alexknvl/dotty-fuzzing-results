trait I0 {
trait I1 {
type I5 <: I5
}
abstract class I5 {
type I5
type I5 <: I5 {
type I1 <: I5
}
def I5 = 0
val I5: I0
object I5
}
object I5 extends I0
object I5 {
import I0.I5.{ I5 =>
object I5.I5.I5
}
}
class I5 {
implicit def main() = I5 match {
case 1 => val I5 = i2
}
implicit def I1 = I1
sealed class I4 {
def i3(): Unit = {
println()
extends object type I5 extends I5
}
trait I1 { type I5 }
trait I5[I5, I5 <: I5 { type I1 }
type I5 <: I5.I5
type I5[I5, I5] = I5[I1]
type I1[I5]
}
trait i3 extends I5 {
type I1 <: I0
}
trait I5[I5]
trait I5[I5, I5 <: I5, I5 <: I5[I5, I5]] {
val I5: I5
type I5 <: I5[I5] <: I0[I5]
val I1: I5[Int] = I1[Int]
}