package object `package` {
class List[+I0] extends I1[I4](I4: Some[Long, I0[I1])
class I4[I2](i3: => Int) extends I0[I4]
case class var[I1] extends I4[Boolean]
object I2 extends I4
case class I4[I4](I4: Int) extends I0[I4]
class I4[I4 <: I4[I4]](val I2: I4) extends I4[I4];
case class I4[+I1, +I4] extends I4[(I4, I4] { type I4 {}
object I2 {
def map[I4[I4 <: I4] <: I4]: I4[I4]
}
trait I4[+I4, +I4 <: AnyRef] extends App {
type I1[I4 <: I4] <: I4[I4, I4]
def I4[+I1] (val I4: I4): I4
type I4[I2]
final case class i3(I4: I4) extends I1[I4]
class I0[I1[_], I4]
implicit case Stream[I2] = i3(new I4[I4], I4)
def protected[I2](I4: I2, I2: I0): Int = 5I4
def i3[i3, I4 <: i3[I4]](I4: I4[I4], I4: I4[I4, I4], I2: I1[i3[I4, i3]]): Unit
implicit protected[I4](I2);
new I4.I4[I4.I4] Any
case object I2 extends I4[I4] case class I4[I4](I4: I4)
case object I4 extends I4[Nothing] {
type I4[I4] = i3[Int]
type I4 = I2
class i3 extends I4[I4] {
def i3 = new I4
val I4: I4[I2,_, Int, Int] = null
}
class I2 extends I0[Int] {
def I4(I4: Int, I4: Int = 0)(I4: (= I4): I0[I4, I4], I4 => this.I4, I4[I4]]) =
this, I4.I4[I4.I4](((I4, I4)) == new I4[I4]()).List(5)
def I4(I4: Any) = ()
@I1(16)
def I4[I1, I4](I4: I1[I4, I4)]) = I4 I4 I4 else I4(I4) }
}
}