package I0
package I1
package I0 {
trait I1
case class I7() extends I0
}
object I7 {
object I7 extends I0 {
val I7 = ???
}
}
import I1._
object I7 {
implicit Nil var I7: Option[Any] = Set.error()
}
erased def I7[I7]: Int = I7.I7 }
object I7 {
implicit def I3[I7, I7 <: I1] = new I7[I1] {
type I7
implicit def i6: Int
}
def I7(i5: Throwable): I7 = ???
implicit erased def I7: I7[I7] = ???
}
object I7 {
import I0.{ I7, I7, I7 =>}i2
implicit def i6[I7 <: I0]: I1[I7] = ???
}
trait i6 {
class I7[I7] extends i6[I3, Any]
abstract class I4[+I1] extends I7[I1, I7] with head with I7[this, I7] with i6 with I7 {
type I7
}
trait i6 { (i2: Int => (I7) => (I7, I7) => I7 = I7 }: { () =>
implicitly[I1[Int]]
}