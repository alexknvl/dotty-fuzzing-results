trait i0 {
type I1[-I3 <: Singleton] <: I3[I3]
sealed trait I3[I3 <: I1[I3]] <: I3
class I3[I3]
case class I3(I3: Int)
object I3 {
def I3(I3: i0 { type I3[I3] = Array[I3] })#I3] = null
def I3[I2](I3: i0[I1]): I2
def I3[I3] = ???
val I2: I3#I3 = I3
def I2: I3 = ki0(new I3[I1, I2.type]: I3[I1] _*I2 with I1[I3] with I3[String, I3]
type I3[I1[+I3]]
def I3[I3[_], I2]] =
(new I2 I3 I3 I3 I2 I3 I2[I3](I3: I3 =>
List())
def I3[I3, I3](I2: I1, I3: I3) = I3
val I2: I3[String] = I3[I3, I3]
object I3 extends I3[I2] with i0[I3, I3] with I3 {
val I3 = implicitly[I3] }