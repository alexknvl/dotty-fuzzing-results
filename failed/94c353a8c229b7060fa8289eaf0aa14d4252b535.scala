object I0 {
type i1
type I7 <: I0
val I7: i1
}
abstract class I7 extends I7 {
private var I0 = new i1.I7.I7
val I7: I0 = I7
def I7 = new I0
}
object I7 {
import I0.{ i1, i5, I7, i5 }
type I7 = I7 { type i1 <: I7.type }
type i2 <: I7
type I7 = I7.type
val I7 = I4
val i5 = i2
val I3: Symbol = new i5
val I7 = Seq with i2
val i5 = I7
val I3 = new i5
val I7 = new I7
val i5 = I4
val I7 = new I7
(null: I7) match {
case _: i2 => println
}
case class i2(I7: Int)
implicit val I6: Int = 42
def i5(): Unit =
new i1 + I7
}
implicit class I7 {
val i2 = new I7('I7)
}
package I0;
abstract class I7 {
def I7(): Int = 5
def I7: Any = ???
val i5: Int = ???
}
object I0 {
def i1(I7: Int) = i1 match { case _ => I3 })
}