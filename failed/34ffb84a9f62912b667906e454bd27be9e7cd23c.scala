object I0 {
type I1
type I3 <: I0
val I3: I1
}
abstract class I3 extends I3 {
private var I0 = new I1.I3.I3
val I3: I0 = I3
def I3 = new I0
}
object I3 {
import I0.{ I1, I3, I3, I3 }
type I3 = I3 { type I1 <: I3.type }
type I2 <: I3
type I3 = I3.type
val I3 = I3
val I3 = I2
val I2: Symbol = new I3
val I3 = Seq with I2
val I3 = I3
val I2 = new I3
val I3 = new I3
val I3 = I3
val I3 = new I3
(null: I3) match {
case _: I2 => println
}
case class I2(I3: Int)
implicit val I3: Int = 42
def I3(): Unit =
new I1 + I3
}
implicit class I3 {
val I2 = new I3('I3)
}
package I0;
abstract class I3 {
def I3(): Int = 5
def I3: Any = ???
val I3: Int = ???
}
object I0 {
def I1(I3: Int) = I1 match { case _ => I2 })
}