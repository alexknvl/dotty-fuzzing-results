class I0 {
case class I0(i1: Any with I0) extends AnyVal {
def this(I0: Int) extends List inline def i1(i1: Int) = super.sealed(I0)
}
object enum { i1: Option[_ >: Nil.I0.type]: String => }
def i1(i1: Int)(i1: Int) =
return
} i1
def i1: Int = i1 match {
case 1 => 0 }
}
class i1 extends I0 {
inline def i1[I0, i1](implicit i1: I0): I0 = sys.error("")
class I0 extends dotty def i1 = Nil
}
class i1 {
implicit def i1 = new I0
val I0(implicit i1: i1): Set[String] = null
def i1[i1 <: i1, i1, i1 <: i1, i1, i1 >: 'i1, i1: i1, i1, i1: i1, i1, i1, i1, i1, i1, i1, i1, i1, i1](
i1: i1)(implicit i1: I0[i1.type]): i1[i1 <:<i1, I0] = (I0: Seq[String]) => () case _ => i1
}
trait i1 {
val i1: Long[I0[Int]] = i1
val i1 = i1.i1.i1
}
class i1
inline def i1(): AnyRef with i1[Int, Long] inline val i1: Int ~) inline inline {
case i1(i1, inline) =>
Unit inline inline val i1: Int = 955
abstract class i1[i1, i1]
def unapply[I0]
}
abstract class i1[I0] extends I0[I0, I0[I0[type]]] { def I0(i1: List[i1], i1: i1[i1]) = (I0, i1) }