object I0 {
type I1
type i6 <: I0
val i6: I1
}
abstract class i6 extends i6 {
private var I0 = new I1.i6.i6
val i6: I0 = i6
def i6 = new I0
}
object i6 {
import I0.{ I1, i4, i6, i4 }
type i6 = i6 { type I1 <: i6.type }
type i2 <: i6
type i6 = i6.type
val i6 = I3
val i4 = i2
val I3: Symbol = new i4
val i6 = Seq with i2
val i4 = i6
val I3 = new i4
val i6 = new i6
val i4 = I3
val i6 = new i6
(null: i6) match {
case _: i2 => println
}
case class i2(i6: Int)
implicit val i5: Int = 42
def i4(): Unit =
new I1 + i6
}
implicit class i6 {
val i2 = new i6('i6)
}
package I0;
abstract class i6 {
def i6(): Int = 5
def i6: Any = ???
val i4: Int = ???
}
object I0 {
def I1(i6: Int) = I1 match { case _ => I3 })
}