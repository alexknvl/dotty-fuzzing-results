object i0 {
def i1[i7](i7: String)(i7: => i7): Unit = ()
def i7[i1, i7, i7[i1]](i7: i1[i7]): i7[i7] = new i7[i7] {
def i7(i7: i7): i7 = null
def i7[i7[_[_]]]](i7: i7[i7]): i7[i7]
}
class i7(val i7: Int, i1: String) {}
case class i7[i7, i7](I2: i7) extends i7[i7, i1, i1[i7]] {
def i5: i7[i3] = i3(1, i7))
println(i5 += null)
def i3 = new I2 with i3 => null
val i5 = Some (i7, I2) = i3 += i7 match {
case _: i0[i7] => i7.head
}
}
sealed iterator object i7 }
trait i7[I2] extends i1[i7]
trait i5[+i7, +i7] {
def i7: i7[i7] = new i1[i7]
sealed trait i7 { type i7[i7] }
type i7 = i7 { type i7[i7] = i7[i7] }: Any = this <: i3 map i7 yield i7 i6 : i7 =>
def i4: String => Double
}
trait i6 {
type i7
}
trait i7 {
type i1[i7] = (Int, map: Int)
lazy val i7: i0[Int] = i3
}
package i7 {
import i1.{ implicitly => } }
}