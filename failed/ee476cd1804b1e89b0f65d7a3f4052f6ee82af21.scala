object i0 {
abstract class i0 { i1: i1 =>
def <: (i0): Null;
assert.i1
}
class i1 {
def i1(i1: Int): i0
private type i1 = _ with i1;
val i1: List[Int] = List(1, 2, 2);
i1: Any if AnyRef { i0(2) })
}
object i1 {
type i1 = i0 Array abstract class i1 {
type i1
def i1(i1: i0): String =
i1 match {
case i1: i0 => i1.length
}
def i1 = i1(1) val i1 = new i1.i0 {}
}
object i0 {
def ??[i1 <: Any, i1 <i1, i0, i0, i0 <: i1, i0 <: i1, i0, i0, i1, i1, i0, i0, i0](i1: i1, i0 <1: i1[i1]) = i1
}
object i1 extends i0[i0[Int, String]]
implicit def i1[i1 <: i0]: String > Option[i1] = ???
i0(0)
}