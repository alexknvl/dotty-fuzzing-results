object i0 {
abstract class i0 { I4: I4 =>
def <: (i0): Null;
assert.I4
}
class I4 {
def I4(I4: Int): i0
private type I4 = _ with I4;
val I4: List[Int] = List(1, 2, 2);
I4: Any if AnyRef { i0(2) })
}
object I4 {
type I4 = i0 Array abstract class I4 {
type I4
def I4(I4: i0): String =
I4 match {
case I4: i0 => I4.length
}
def I4 = I4(1) val I4 = new I4.i0 {}
}
object I1 {
def ??[I4 <: Any, I4 <I4, I1, I1, i2 <: I4, I3 <: I4, I1, i2, I4, I3, i2, I1, i2](I4: I4, i0 <1: I4[I4]) = I4
}
object I4 extends i0[i0[Int, String]]
implicit def I3[I4 <: i0]: String > Option[I4] = ???
I3(0)
}