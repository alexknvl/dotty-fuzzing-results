class I0 {
class I1
trait i3 extends I1
abstract class i3 {
type i3[_ <: Traversable[this.i3, i3]] <: i3[I1]
for (i3 < next)
val I1: String => i3.i3;
trait i3 {
type i3 <: i3;
abstract class i3() extends i3
val I1 = i3()
val i3 = new i3().I1() }
class I1 extends i3[i3](val i3: I0#i3) {
def i3: i3 = null;
val i3: i3.i3 = new i3;
val i3 = new i3 ({ val i3: Int; var I1 = '42 }
class i3 {
def I2(): Unit
def I1(): Unit = () i3 i3 implicit val I2 = i3
val I2 =  match { case I2(_) => i3 }
def i3(): Unit = ();
def I1(i3: String) = i3
}
val i3 = new i3[I1, i3](I1)
class i3 extends i3 { def i3 = 0 }
}
trait i3 {
implicit val I1: i3 = _
def I1(I1: => Int = ()) = I1
i3
override type i3 = i3[i3]
type i3[+i3] <: I0[I2] <: i3[I1, i3]](I2: Int => i3): Any =
(i3, i3) match {
case None: I1[List, Int] => Some(i3, head else new i3)
}
}