trait I0 {
trait I0 {
type I2 <: I2
}
abstract class I2 {
type I2
type I2 <: I2 {
type I0 <: I2
}
def I2 = 0
val I2: I0
object I2
}
object I2 extends I0
object I2 {
import I0.I2.{ I2 =>
object I2.I2.I2
}
}
class I2 {
implicit def main() = I2 match {
case 1 => val I2 = i1
}
implicit def I0 = I0
sealed class I2 {
def i1(): Unit = {
println()
extends object type I2 extends I2
}
trait I0 { type I2 }
trait I2[I2, I2 <: I2 { type I0 }
type I2 <: I2.I2
type I2[I2, I2] = I2[I0]
type I0[I2]
}
trait i1 extends I2 {
type I0 <: I0
}
trait I2[I2]
trait I2[I2, I2 <: I2, I2 <: I2[I2, I2]] {
val I2: I2
type I2 <: I2[I2] <: I0[I2]
val I0: I2[Int] = I0[Int]
}