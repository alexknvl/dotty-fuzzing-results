class I0 {
case class I0(I1: Any with I0) extends AnyVal {
def this(I0: Int) extends List inline def I1(I1: Int) = super.sealed(I0)
}
object enum { I1: Option[_ >: Nil.I0.type]: String => }
def I1(I1: Int)(I1: Int) =
return
} I1
def I1: Int = I1 match {
case 1 => 0 }
}
class I1 extends I0 {
inline def I1[I0, I1](implicit I1: I0): I0 = sys.error("")
class I0 extends dotty def I1 = Nil
}
class I1 {
implicit def I1 = new I0
val I0(implicit I1: I1): Set[String] = null
def I1[I1 <: I1, I1, I1 <: I1, I1, I1 >: 'I1, I1: I1, I1, I1: I1, I1, I1, I1, I1, I1, I1, I1, I1, I1](
I1: I1)(implicit I1: I0[I1.type]): I1[I1 <:<I1, I0] = (I0: Seq[String]) => () case _ => I1
}
trait I1 {
val I1: Long[I0[Int]] = I1
val I1 = I1.I1.I1
}
class I1
inline def I1(): AnyRef with I1[Int, Long] inline val I1: Int ~) inline inline {
case I1(I1, inline) =>
Unit inline inline val I1: Int = 955
abstract class I1[I1, I1]
def unapply[I0]
}
abstract class I1[I0] extends I0[I0, I0[I0[type]]] { def I0(I1: List[I1], I1: I1[I1]) = (I0, I1) }