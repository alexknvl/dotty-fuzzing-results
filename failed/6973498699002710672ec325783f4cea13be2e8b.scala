object I0 {
trait i1[i1]
implicit val I2: I0 & i1
}
trait I2 {
import I0.{ i1 =>
sealed: Symbol
}
def I2[I2] = super.i1[List, I2](I2[I2]) = sys.error()
}
class I2 extends I0 {
def update[I2 <: Option, I2[I2 <: I2]](I2: I0 => I0[I2]): i1[i1] = I2
}
class I2 extends I2 {
type I2[_] = I2
val I2 = false
val I2: Int
val I2 = I2
val I2 = List()
def i1[I2](I2: I2): I2 = {
I2.I2(I2) + I2
val i1: (i1 forSome { override def i1(i1: String*) = I2 }
}