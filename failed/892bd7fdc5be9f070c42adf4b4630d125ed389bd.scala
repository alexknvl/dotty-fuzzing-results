object I0 {
trait I0 extends I0
sealed trait I2 {
type I2 <: I2
type I2[I2 <: I2[I2]] <: I2[I2, I2]
trait I2 {
type I2 <: I2.I2
type i1[I2[I2 <: I2]]? <: I2;
trait I2 extends I2[String] with I2[this] import reflect.i1.I2[I2] val i1 = 1 val I2 = new I2[I2 with I2] trait I2[I2] extends I2[I2] object I2 {}
case class i1(I2: Int)(private val I0: Int) {
var i1 = _
}
implicit val i1 = I2 protected {
val I2 = new I2
def I0[I2[_]](I2: I0[I2]): I2[_]
}