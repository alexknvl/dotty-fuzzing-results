class I0
object I1 {
implicit def main(I0: Array[String]): Unit = {
this.I1()(2) match {
case I5 => 0 => I1
case I1: List[Int] => ()
}
def I5(I5: Int) = I5 match {
case I0(I5) => +
}
def main(I5: Array[String]): Unit =
List(new AnyRef)
new I1[Int]() {}
new I0() {}
}
object I5 {
type I5 = super.type
var I5: String;
def I1[I5 <: I5](implicit I5: I5, I5: I5.I5): I5.I5 = I5 + I5 })
I1: I5.head
}
implicit class I2[I1](val I5: I0) extends I0
object i4 {
def this[I1](I1: Int) = 0
def I5[I5](I2: I0[String, String]): I1[Int] = I1 match {
case I1(I5) => (I5(I5: @extends _*) => _)
case _ => Some(I3)
}
}
abstract class I1[+I5](I5: => String, I5: scala.Double[I5]) {
def I1[_](I1: => I5): I5.I5[I0] = new I0(10)
val I3 = new I0[Int].I5(I1 = 1) }
object I1 {
(I5(new I1(Array(0, 0)) forSome { List(I5, I1, I2) { I5.I5 } println(1) yield I1{
val I3 = List(I5, map, I5 => i4)
case I5(I2) => println(I5: Int) match {
case I5(I5) => I5
println( + I5)
}
}