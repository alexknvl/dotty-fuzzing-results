object I0 {
def i1[I6](I6: String)(I6: => I6): Unit = ()
def I6[i1, I6, I6[i1]](I6: i1[I6]): I6[I6] = new I6[I6] {
def I6(I6: I6): I6 = null
def I6[I6[_[_]]]](I6: I6[I6]): I6[I6]
}
class I6(val I6: Int, i1: String) {}
case class I6[I6, I6](i2: I6) extends I6[I6, i1, i1[I6]] {
def I5: I6[i4] = i4(1, I6))
println(I5 += null)
def i3 = new i2 with i3 => null
val I5 = Some (I6, i2) = i3 += I6 match {
case _: I0[I6] => I6.head
}
}
sealed iterator object I6 }
trait I6[i2] extends i1[I6]
trait I5[+I6, +I6] {
def I6: I6[I6] = new i1[I6]
sealed trait I6 { type I6[I6] }
type I6 = I6 { type I6[I6] = I6[I6] }: Any = this <: i3 map I6 yield I6 I6 : I6 =>
def I5: String => Double
}
trait I6 {
type I6
}
trait I6 {
type i1[I6] = (Int, map: Int)
lazy val I6: I0[Int] = i4
}
package I6 {
import i1.{ implicitly => } }
}