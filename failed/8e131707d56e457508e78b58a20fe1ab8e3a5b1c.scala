object I0 {
def i1[I5](I5: String)(I5: => I5): Unit = ()
def I5[i1, I5, I5[i1]](I5: i1[I5]): I5[I5] = new I5[I5] {
def I5(I5: I5): I5 = null
def I5[I5[_[_]]]](I5: I5[I5]): I5[I5]
}
class I5(val I5: Int, i1: String) {}
case class I5[I5, I5](i2: I5) extends I5[I5, i1, i1[I5]] {
def I4: I5[I4] = I4(1, I5))
println(I4 += null)
def I3 = new i2 with I3 => null
val I4 = Some (I5, i2) = I3 += I5 match {
case _: I0[I5] => I5.head
}
}
sealed iterator object I5 }
trait I5[i2] extends i1[I5]
trait I4[+I5, +I5] {
def I5: I5[I5] = new i1[I5]
sealed trait I5 { type I5[I5] }
type I5 = I5 { type I5[I5] = I5[I5] }: Any = this <: I3 map I5 yield I5 I5 : I5 =>
def I4: String => Double
}
trait I5 {
type I5
}
trait I5 {
type i1[I5] = (Int, map: Int)
lazy val I5: I0[Int] = I4
}
package I5 {
import i1.{ implicitly => } }
}