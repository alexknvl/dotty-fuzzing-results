object i0 {
abstract class i0 { i3: i3 =>
def <: (i0): Null;
assert.i3
}
class i3 {
def i3(i3: Int): i0
private type i3 = _ with i3;
val i3: List[Int] = List(1, 2, 2);
i3: Any if AnyRef { i0(2) })
}
object i3 {
type i3 = i0 Array abstract class i3 {
type i3
def i3(i3: i0): String =
i3 match {
case i3: i0 => i3.length
}
def i3 = i3(1) val i3 = new i3.i0 {}
}
object i0 {
def ??[i3 <: Any, i3 <i3, i0, i0, i1 <: i3, i1 <: i3, i0, i0, i3, i2, i1, i0, i1](i3: i3, i0 <1: i3[i3]) = i3
}
object i3 extends i0[i0[Int, String]]
implicit def i2[i3 <: i0]: String > Option[i3] = ???
i2(0)
}