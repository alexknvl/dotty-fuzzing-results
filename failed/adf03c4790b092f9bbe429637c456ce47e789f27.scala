trait I0 {
type I0[-I2 <: Singleton] <: I2[I2]
sealed trait I2[I2 <: I0[I2]] <: I2
class I2[I2]
case class I2(I2: Int)
object I2 {
def I2(I2: I0 { type I2[I2] = Array[I2] })#I2] = null
def I2[i1](I2: I0[I0]): i1
def i1[i1] = ???
val i1: I2#I2 = I2
def i1: I2 = kI0(new I2[I0, i1.type]: I2[I0] _*i1 with I0[I2] with I2[String, I2]
type I2[I0[+I2]]
def I2[I2[_], i1]] =
(new i1 i1 I2 I2 i1 i1 i1[i1](I2: I2 =>
List())
def i1[I2, I2](i1: I0, i1: I2) = i1
val i1: I2[String] = I2[I2, I2]
object i1 extends I2[i1] with I0[I2, I2] with I2 {
val I2 = implicitly[I2] }