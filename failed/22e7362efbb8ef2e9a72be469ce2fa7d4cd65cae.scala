trait I0[+i1[_], i4[i4] <- i4[i1]]: I0[Option]] {}
trait i4[i1]
object i4 {
abstract class i1 {
type i4[i4]
def i4[i4, i4 <: i1] = new i4[i4]
}
implicit def i4[i4](i4: i4): i4.i4[String] = i4[i1]
def i4(i4: Array[i4]): Unit
}
class I2 extends i4 {
case object I2 extends i4[I0[Int]]
object i4 extends i4[i1] object i4 extends i4[Any, i4]
case class I3[i4[i4] extends AnyVal {
trait i4 {
type I2
protected[i1](implicit i4 <= I3 <: i4) extends I3[i4];
case class I3() extends i4[i1, i4]
object I3 {
implicit val I3 = (new i1)
}
val I3 = i4 {
lazy val I3 = 10
I2 match {
case i4(Some(_)) => 10
}
}
I3: i4[i4] {
def selectDynamic[i4: i4](i4: i4 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I2 {
def I3[@specialized(Int) i4](i4: i4)(I3: i4[I2]) = i4(i4)
}