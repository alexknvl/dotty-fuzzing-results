object i0 {
trait i0 extends i0
sealed trait I3 {
type I3 <: I3
type I3[I3 <: I3[I3]] <: I3[I3, I3]
trait I3 {
type I3 <: I3.I3
type I3[I3[I3 <: I3]]? <: I3;
trait I3 extends I3[String] with I3[this] import reflect.I3.I3[I3] val i2 = 1 val I3 = new I3[I3 with I3] trait I3[I3] extends I3[I3] object I3 {}
case class I3(I3: Int)(private val i1: Int) {
var i1 = _
}
implicit val I3 = I3 protected {
val I3 = new I3
def i1[I3[_]](I3: i0[I3]): I3[_]
}