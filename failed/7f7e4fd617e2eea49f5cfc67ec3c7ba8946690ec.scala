class I0
object i1 {
implicit def main(I0: Array[String]): Unit = {
this.i1()(2) match {
case i6 => 0 => i1
case i1: List[Int] => ()
}
def i6(i6: Int) = i6 match {
case I0(i6) => +
}
def main(i6: Array[String]): Unit =
List(new AnyRef)
new i1[Int]() {}
new I0() {}
}
object i6 {
type i6 = super.type
var i6: String;
def i1[i6 <: i6](implicit i6: i6, i6: i6.i6): i6.i6 = i6 + i6 })
I2: i6.head
}
implicit class I2[i1](val i6: I0) extends I0
object I5 {
def this[i1](i1: Int) = 0
def i6[i6](I2: I0[String, String]): i1[Int] = i1 match {
case i1(i6) => (i6(i6: @extends _*) => _)
case _ => Some(I3)
}
}
abstract class i1[+i6](i6: => String, i6: scala.Double[i6]) {
def i1[_](i1: => i6): i6.i6[I0] = new I0(10)
val I3 = new I0[Int].i6(i1 = 1) }
object i1 {
(i6(new i1(Array(0, 0)) forSome { List(i6, I2, I2) { i6.i6 } println(1) yield I2{
val I3 = List(i6, map, i6 => I4)
case i6(I2) => println(i6: Int) match {
case i6(i6) => i6
println( + i6)
}
}