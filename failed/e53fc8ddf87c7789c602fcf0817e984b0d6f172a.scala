trait i0[+i0[_], i2[i2] <- i2[i0]]: i0[Option]] {}
trait i2[i0]
object i2 {
abstract class i0 {
type i2[i2]
def i2[i2, i2 <: i0] = new i2[i2]
}
implicit def i2[i2](i2: i2): i2.i2[String] = i2[i0]
def i2(i2: Array[i2]): Unit
}
class I1 extends i2 {
case object I1 extends i2[i0[Int]]
object i2 extends i2[i0] object i2 extends i2[Any, i2]
case class i2[i2[i2] extends AnyVal {
trait i2 {
type I1
protected[i0](implicit i2 <= I1 <: i2) extends I1[i2];
case class i2() extends i2[i0, i2]
object i2 {
implicit val I1 = (new i0)
}
val i2 = i2 {
lazy val I1 = 10
I1 match {
case i2(Some(_)) => 10
}
}
I1: i2[i2] {
def selectDynamic[i2: i2](i2: i2 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I1 {
def I1[@specialized(Int) i2](i2: i2)(I1: i2[I1]) = i2(i2)
}