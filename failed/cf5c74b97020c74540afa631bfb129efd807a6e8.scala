trait i0 {
type I1[-I4 <: Singleton] <: I4[I4]
sealed trait I4[I4 <: I1[I4]] <: I4
class I4[I4]
case class I4(I4: Int)
object I4 {
def I4(I4: i0 { type I4[I4] = Array[I4] })#I4] = null
def I4[i2](I4: i0[I1]): i2
def i3[I4] = ???
val i3: I4#I4 = I4
def i3: I4 = ki0(new I4[I1, i3.type]: I4[I1] _*i3 with I1[I4] with I4[String, I4]
type I4[I1[+I4]]
def I4[I4[_], i3]] =
(new i3 I4 I4 I4 i2 i3 i3[I4](I4: I4 =>
List())
def i3[I4, I4](i3: I1, i3: I4) = i3
val i3: I4[String] = I4[I4, I4]
object i3 extends I4[i2] with i0[I4, I4] with I4 {
val I4 = implicitly[I4] }