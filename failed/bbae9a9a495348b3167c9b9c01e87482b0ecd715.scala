trait i0[+i1[_], i7[i7] <- i7[i1]]: i0[Option]] {}
trait i7[i1]
object i7 {
abstract class i1 {
type i7[i7]
def i7[i7, i7 <: i1] = new i7[i7]
}
implicit def i7[i7](i7: i7): i7.i7[String] = i7[i1]
def i7(i7: Array[i7]): Unit
}
class i2 extends i7 {
case object i2 extends i7[i0[Int]]
object i6 extends i7[i1] object i7 extends i7[Any, i7]
case class I4[i7[i6] extends AnyVal {
trait i6 {
type i2
protected[i1](implicit i7 <= I3 <: i7) extends I3[i7];
case class I4() extends i7[i1, i7]
object I5 {
implicit val I3 = (new i1)
}
val I5 = i7 {
lazy val I3 = 10
i2 match {
case i7(Some(_)) => 10
}
}
I3: i7[i7] {
def selectDynamic[i6: i7](i7: i7 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class i2 {
def I3[@specialized(Int) i7](i7: i7)(I3: i7[i2]) = i7(i7)
}