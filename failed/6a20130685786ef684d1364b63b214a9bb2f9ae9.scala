class i0
object i0 {
implicit def main(i0: Array[String]): Unit = {
this.i0()(2) match {
case i5 => 0 => i0
case i0: List[Int] => ()
}
def i5(i5: Int) = i5 match {
case i0(i5) => +
}
def main(i5: Array[String]): Unit =
List(new AnyRef)
new i0[Int]() {}
new i0() {}
}
object i5 {
type i5 = super.type
var i5: String;
def i0[i5 <: i5](implicit i5: i5, i5: i5.i5): i5.i5 = i5 + i5 })
I2: i5.head
}
implicit class I3[i0](val i5: i0) extends i0
object i4 {
def this[i0](i1: Int) = 0
def i5[i5](I3: i0[String, String]): i0[Int] = i1 match {
case i0(i5) => (i5(i5: @extends _*) => _)
case _ => Some(I3)
}
}
abstract class i1[+i5](i5: => String, i5: scala.Double[i5]) {
def i1[_](i1: => i5): i5.i5[i0] = new i0(10)
val I3 = new i0[Int].i5(i1 = 1) }
object i1 {
(i5(new i0(Array(0, 0)) forSome { List(i5, I2, I3) { i5.i5 } println(1) yield I2{
val I3 = List(i5, map, i5 => i4)
case i5(I3) => println(i5: Int) match {
case i5(i5) => i5
println( + i5)
}
}