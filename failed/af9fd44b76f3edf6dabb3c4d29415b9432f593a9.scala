class i0
object i1 {
implicit def main(i0: Array[String]): Unit = {
this.i1()(2) match {
case i7 => 0 => i1
case i1: List[Int] => ()
}
def i7(i7: Int) = i7 match {
case i0(i7) => +
}
def main(i7: Array[String]): Unit =
List(new AnyRef)
new i1[Int]() {}
new i0() {}
}
object i7 {
type i7 = super.type
var i7: String;
def i1[i7 <: i7](implicit i7: i7, i7: i7.i7): i7.i7 = i7 + i7 })
i2: i7.head
}
implicit class i3[i1](val i7: i0) extends i0
object i6 {
def this[i1](i1: Int) = 0
def i7[i7](i3: i0[String, String]): i1[Int] = i1 match {
case i1(i7) => (i7(i7: @extends _*) => _)
case _ => Some(i4)
}
}
abstract class i1[+i7](i7: => String, i7: scala.Double[i7]) {
def i1[_](i1: => i7): i7.i7[i0] = new i0(10)
val i4 = new i0[Int].i7(i1 = 1) }
object i1 {
(i7(new i1(Array(0, 0)) forSome { List(i7, i2, i3) { i7.i7 } println(1) yield i2{
val i4 = List(i7, map, i7 => I5)
case i7(i3) => println(i7: Int) match {
case i7(i7) => i7
println( + i7)
}
}