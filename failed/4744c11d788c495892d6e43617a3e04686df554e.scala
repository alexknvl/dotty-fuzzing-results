object i0 {
abstract class i0[i0]
case class I1[i0]()
}
final class I1 extends i0 {
type i0[+i0] <: i0[i0] <: i0[I1]
def I1[I1 <: i0[I1]]: i0[I1] = I1[i0]
def I2[i3 <: i0[I1]](i3: i0): i3[I2 #: I1] = I2 match {
case _: i0 => I2.i0(i3)
case _ => None
case i0(I2) => I1
}
def I2[I1 <: List[I1]](i3: I2[I1]): i0[I1] =
I2.i3.collect(
i3 = 0)
case _ => sys.error("")
new I1[Int](10)
}
val i3: i0[Int] = null
}