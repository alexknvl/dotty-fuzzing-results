abstract class i0 {
abstract class I1
object I6 {
type I6 = I1.I6
}
class I6 extends I6 {
protected override def I1 = this + I6 + I6
}
val I6 = null
implicit def I6: i0 { type I1 = I1 } = I6
}
trait I6 {
implicit val I6: I1
type I6
val I6: I6
I6 forSome { type I6 <: I6 }
type I6 = String => Int = I6
}
object I2 {
type I1 = { val I6 = implicitly[I6] }
}
final case class i4() extends I6[I1, I6]
object I6 {
def I3(I6: I1[Int]): Int = 1
}
object I2 extends i0[I6]
object I2 extends I6[String, +I6] { private override def I6: Int = 0 def I6: Unit = }
def unapply[I6[I6]] = new i0[I6] { def toString = I6.type }
class I3 extends I6[Long, I1] {
def I2(I3: Int): Int def I6(I2: I6[I6]): I1[I6] = true
def I6[i5 <: super] = i5[I6]
val I6 = new i5
val i4 = I6[I6[I2]]
implicit def i5[I6](implicit I6: I6[I6], I6: I6[I6]): Array[I2 <: I6] = ???
def I6[i5 <: I6[I6], I6[I6], i5[I6] <: I6] => I6 <: I6](I3: Any*) = (new I1[i4, I6])(i5 i4 + I2, i5 <: I3) yield implicit implicitly[I2], I6(I6, I2, I2)) {
def i4(I3: I6, i5: I2): I1[I6]
def I2[I6, I2[_ >: I6]]: I1[I1[I6]] = I3 implicit def i4[I6 <: I2] = i5 with I6] extends I6[I1, I6] {
def I6: I2[i4[String]] = I2()
type I3[I6] => Option[I6, Long[I6], I2]]
type I6[I6 <: I6] = (I6, I6, I6)
case class I6[I6](I6: I6 => Int) extends I6
abstract class I6[I2, Boolean] {}
case class i5(val I6: I6[_, this], I3: i0[Int, Int]) extends i0[I6]
trait I2[i5] extends i0[I6, String] }