package object `package` {
class List[+I0] extends I0[i5](i5: Some[Long, I0[I0])
class i5[I1](I3: => Int) extends I0[i5]
case class var[I0] extends i5[Boolean]
object I1 extends i5
case class i5[i5](i5: Int) extends I0[i5]
class i5[i5 <: i5[i5]](val I1: i5) extends i5[i5];
case class i4[+I0, +i5] extends i5[(i4, i5] { type i5 {}
object I1 {
def map[i5[i5 <: i5] <: i5]: i5[i5]
}
trait i5[+i5, +i5 <: AnyRef] extends App {
type I0[i5 <: i5] <: i5[i5, i5]
def i5[+I0] (val i5: i5): i5
type i5[I1]
final case class i2(i5: i5) extends I0[i5]
class I0[I0[_], i5]
implicit case Stream[I1] = I3(new i5[i5], i5)
def protected[I1](i5: I1, I1: I0): Int = 5i4
def i2[I3, i5 <: i2[i5]](i5: i5[i5], i4: i5[i5, i5], I1: I0[I3[i5, I3]]): Unit
implicit protected[i5](I1);
new i4.i5[i5.i5] Any
case object I1 extends i5[i5] case class i5[i5](i5: i5)
case object i5 extends i5[Nothing] {
type i5[i5] = I3[Int]
type i5 = I1
class i2 extends i5[i5] {
def i2 = new i5
val i5: i5[I1,_, Int, Int] = null
}
class I1 extends I0[Int] {
def i5(i5: Int, i5: Int = 0)(i5: (= i5): I0[i5, i5], i5 => this.i5, i5[i5]]) =
this, i5.i5[i5.i5](((i5, i5)) == new i5[i5]()).List(5)
def i5(i5: Any) = ()
@I0(16)
def i5[I0, i5](i5: I0[i5, i5)]) = i5 i5 i5 else i4(i5) }
}
}