trait i0[+I1[_], i6[i6] <- i6[I1]]: i0[Option]] {}
trait i6[I1]
object i6 {
abstract class I1 {
type i6[i6]
def i6[i6, i6 <: I1] = new i6[i6]
}
implicit def i6[i6](i6: i6): i6.i6[String] = i6[I1]
def i6(i6: Array[i6]): Unit
}
class i2 extends i6 {
case object i2 extends i6[i0[Int]]
object I5 extends i6[I1] object i6 extends i6[Any, i6]
case class i3[i6[i6] extends AnyVal {
trait I5 {
type i2
protected[I1](implicit i6 <= i3 <: i6) extends i3[i6];
case class i3() extends i6[I1, i6]
object i4 {
implicit val i3 = (new I1)
}
val i4 = i6 {
lazy val i3 = 10
i2 match {
case i6(Some(_)) => 10
}
}
i3: i6[i6] {
def selectDynamic[I5: i6](i6: i6 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class i2 {
def i3[@specialized(Int) i6](i6: i6)(i3: i6[i2]) = i6(i6)
}