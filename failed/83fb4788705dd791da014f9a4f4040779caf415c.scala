object i0 {
type i0
type I3 <: i0
val I3: i0
}
abstract class I3 extends I3 {
private var i0 = new i0.I3.I3
val I3: i0 = I3
def I3 = new i0
}
object I3 {
import i0.{ i0, I3, I3, I3 }
type I3 = I3 { type i0 <: I3.type }
type i0 <: I3
type I3 = I3.type
val I3 = I2
val I3 = i0
val i1: Symbol = new I3
val I3 = Seq with i0
val I3 = I3
val i1 = new I3
val I3 = new I3
val I3 = I2
val I3 = new I3
(null: I3) match {
case _: i0 => println
}
case class i0(I3: Int)
implicit val I3: Int = 42
def I3(): Unit =
new i0 + I3
}
implicit class I3 {
val i0 = new I3('I3)
}
package i0;
abstract class I3 {
def I3(): Int = 5
def I3: Any = ???
val I3: Int = ???
}
object i0 {
def i0(I3: Int) = i0 match { case _ => i1 })
}