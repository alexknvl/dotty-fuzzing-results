trait I0 {
type I0[-i3 <: Singleton] <: i3[i3]
sealed trait i3[i3 <: I0[i3]] <: i3
class i3[i3]
case class i3(i3: Int)
object i3 {
def i3(i3: I0 { type i3[i3] = Array[i3] })#i3] = null
def i3[I0](i3: I0[I0]): I0
def I2[i3] = ???
val I0: i3#i3 = i3
def I0: i3 = kI0(new i3[I0, I0.type]: i3[I0] _*I0 with I0[i3] with i3[String, i3]
type i3[I0[+i3]]
def i3[i3[_], I0]] =
(new I0 i3 i3 i3 I0 I2 I0[i3](i3: i3 =>
List())
def I2[i3, i3](i1: I0, I2: i3) = I2
val i1: i3[String] = i3[i3, i3]
object I2 extends i3[I0] with I0[i3, i3] with i3 {
val i3 = implicitly[i3] }