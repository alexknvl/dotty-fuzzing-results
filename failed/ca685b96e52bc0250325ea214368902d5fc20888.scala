class I0
object I1 {
implicit def main(I0: Array[String]): Unit = {
this.I1()(2) match {
case I6 => 0 => I1
case I1: List[Int] => ()
}
def I6(I6: Int) = I6 match {
case I0(I6) => +
}
def main(I6: Array[String]): Unit =
List(new AnyRef)
new I1[Int]() {}
new I0() {}
}
object I6 {
type I6 = super.type
var I6: String;
def I1[I6 <: I6](implicit I6: I6, I6: I6.I6): I6.I6 = I6 + I6 })
i2: I6.head
}
implicit class i3[I1](val I6: I0) extends I0
object I5 {
def this[I1](I1: Int) = 0
def I6[I6](i3: I0[String, String]): I1[Int] = I1 match {
case I1(I6) => (I6(I6: @extends _*) => _)
case _ => Some(i4)
}
}
abstract class I1[+I6](I6: => String, I6: scala.Double[I6]) {
def I1[_](I1: => I6): I6.I6[I0] = new I0(10)
val i4 = new I0[Int].I6(I1 = 1) }
object I1 {
(I6(new I1(Array(0, 0)) forSome { List(I6, i2, i3) { I6.I6 } println(1) yield i2{
val i4 = List(I6, map, I6 => I5)
case I6(i3) => println(I6: Int) match {
case I6(I6) => I6
println( + I6)
}
}