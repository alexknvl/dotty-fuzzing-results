trait i0 {
type I1[-i5 <: Singleton] <: i5[i5]
sealed trait i5[i5 <: I1[i5]] <: i5
class i5[i5]
case class i5(i5: Int)
object i5 {
def i5(i5: i0 { type i5[i5] = Array[i5] })#i5] = null
def i5[I1](i5: i0[I1]): I1
def I3[I4] = ???
val i2: i5#i5 = i5
def i2: i5 = ki0(new i5[I1, i2.type]: i5[I1] _*i2 with I1[i5] with i5[String, i5]
type i5[I1[+i5]]
def i5[i5[_], I3]] =
(new i2 I4 i5 i5 I1 I3 i2[I4](i5: i5 =>
List())
def I3[i5, i5](I3: I1, I3: i5) = I3
val I3: i5[String] = i5[i5, i5]
object I3 extends i5[I1] with i0[i5, i5] with i5 {
val i5 = implicitly[i5] }