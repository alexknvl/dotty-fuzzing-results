object I0 {
abstract class I0 { i5: i5 =>
def <: (I0): Null;
assert.i5
}
class i5 {
def i5(i5: Int): I0
private type i5 = _ with i5;
val i5: List[Int] = List(1, 2, 2);
i5: Any if AnyRef { I0(2) })
}
object i5 {
type i5 = I0 Array abstract class i5 {
type i5
def i5(i5: I0): String =
i5 match {
case i5: I0 => i5.length
}
def i5 = i5(1) val i5 = new i5.I0 {}
}
object i1 {
def ??[i5 <: Any, i5 <i5, i1, i1, i2 <: i5, I3 <: i5, i1, i1, i5, i5, i2, i1, i2](i5: i5, I0 <1: i5[i5]) = i5
}
object i5 extends I0[I0[Int, String]]
implicit def i5[i5 <: I0]: String > Option[i5] = ???
I4(0)
}