trait I0[+i1[_], I6[I6] <- I6[i1]]: I0[Option]] {}
trait I6[i1]
object I6 {
abstract class i1 {
type I6[I6]
def I6[I6, I6 <: i1] = new I6[I6]
}
implicit def I6[I6](I6: I6): I6.I6[String] = I6[i1]
def I6(I6: Array[I6]): Unit
}
class I2 extends I6 {
case object I2 extends I6[I0[Int]]
object I4 extends I6[i1] object I6 extends I6[Any, I6]
case class i3[I6[i5] extends AnyVal {
trait I4 {
type I2
protected[i1](implicit I6 <= i3 <: I6) extends i3[I6];
case class i3() extends I6[i1, I6]
object I4 {
implicit val i3 = (new i1)
}
val I4 = I6 {
lazy val i3 = 10
I2 match {
case I6(Some(_)) => 10
}
}
i3: I6[I6] {
def selectDynamic[I4: I6](I6: I6 => Any = (null: Any) => Unit): implicit Seq[Double]] = List(null: Any)
}
class I2 {
def i3[@specialized(Int) I6](I6: I6)(i3: I6[I2]) = I6(I6)
}