trait i0 {
trait i1 {
type I5 <: I5
}
abstract class I5 {
type I5
type I5 <: I5 {
type i1 <: I5
}
def I5 = 0
val I5: i0
object I5
}
object I5 extends i0
object I5 {
import i0.I5.{ I5 =>
object I5.I5.I5
}
}
class I5 {
implicit def main() = I5 match {
case 1 => val I5 = I2
}
implicit def I2 = I2
sealed class i4 {
def I2(): Unit = {
println()
extends object type I5 extends I5
}
trait I2 { type I5 }
trait I5[I5, I5 <: I5 { type i1 }
type I5 <: I5.I5
type I5[I5, I5] = I5[I2]
type I2[I5]
}
trait i3 extends I5 {
type i1 <: i0
}
trait I5[I5]
trait I5[I5, I5 <: I5, I5 <: I5[I5, I5]] {
val I5: I5
type I5 <: I5[I5] <: i0[I5]
val I2: I5[Int] = I2[Int]
}