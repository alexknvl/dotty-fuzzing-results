trait I0 {
type I0[i1] = { def i1: i1.i1 }
type i1 = I0[Option]
val I2: I0
}
sealed trait I0 extends I0 {
trait I0[+i1, +i1] {
private[this] def I2 = false
def i3: Int = 0
}
object i4 extends App {
type i4[-I2, i3] = super.i1
}
class I2 extends I2 {
type i1
trait i4[+i3]
def flatMap[I2](i4: I2[I2]): i1[i5]
}
class i4 {
implicit def i5: I2 = new i1[i4] { }
}
object i5 {
implicitly[I0[_]]
new i3[I0[i1]]
}